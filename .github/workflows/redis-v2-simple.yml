name: "🚀 Redis Infrastructure – CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: redis-infrastructure
  STACK_NAME: conexao-redis
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: 🔎 Validar identificadores Azure (vars)
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '❌ GitHub Secrets obrigatórios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "✅ Identificadores Azure configurados via secrets"
          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"
          # Key Vault opcional para Redis (infraestrutura simples)
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
            echo 'ℹ️ Key Vault não configurado (Redis não requer segredos complexos)'
          fi
          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo 'ℹ️ AZURE_KEYVAULT_ENDPOINT não definido (usando endpoint padrão)'
          else
            echo '✅ Endpoint customizado definido'
          fi

      - name: Validate Docker Compose
        run: |
          # Validar sintaxe do docker-compose.yml
          docker compose -f docker-compose.yml config -q
          echo "✅ Docker Compose syntax is valid"

      - name: Security Validation
        run: |
          # Verificar se não há hardcoded passwords
          if grep -r "defaultpass\|redisdefaultpassword" docker-compose.yml; then
            echo "❌ Found hardcoded Redis passwords"
            exit 1
          else
            echo "✅ No hardcoded passwords found"
          fi

          # Verificar fail-safe pattern
          if grep -q "FATAL.*refusing to start" docker-compose.yml; then
            echo "✅ Fail-safe security pattern implemented"
          else
            echo "⚠️ Fail-safe pattern recommended but not critical"
          fi

          # Verificar exposição Redis (seguindo padrão RabbitMQ que funcionou)
          if grep -E "^\s*ports:" docker-compose.yml; then
            echo "⚠️ WARNING: Redis may have exposed ports - ensure firewall protection"
            echo "💡 Note: Following RabbitMQ success pattern (commit 66154f5)"
          else
            echo "✅ No ports exposed - maximum security (overlay network only)"
          fi

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [ self-hosted, Linux, X64, conexao-de-sorte-redis-infraestrutura ]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: 🔍 Diagnósticos iniciais
        run: |
          echo "🔍 Verificando arquivos necessários..."
          for required_file in "docker-compose.yml"; do
            if [[ -f "$required_file" ]]; then
              echo "✅ $required_file encontrado"
            else
              echo "❌ $required_file NÃO encontrado"
              exit 1
            fi
          done

          echo "🔍 Validando diretórios críticos..."
          required_dirs=()
          if (( ${#required_dirs[@]} )); then
            for required_dir in "${required_dirs[@]}"; do
              if [[ -d "$required_dir" ]]; then
                echo "✅ Diretório $required_dir existe"
              else
                echo "⚠️ Diretório $required_dir não existe - criando..."
                mkdir -p "$required_dir"
              fi
            done
          else
            echo "ℹ️ Nenhum diretório local obrigatório para Redis"
          fi

      - name: 🔐 Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: 🔐 Get secrets from Azure Key Vault (OIDC)
        id: kv
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        uses: azure/CLI@v1
        with:
          azcliversion: 2.76.0
          inlineScript: |
            set -Eeuo pipefail
            echo "🔐 Buscando secrets do Redis no Key Vault..."
            password=$(az keyvault secret show \
              --vault-name "${{ secrets.AZURE_KEYVAULT_NAME }}" \
              --name "conexao-de-sorte-redis-password" \
              --query value -o tsv)

            if [[ -z "$password" ]]; then
              echo '❌ Secret conexao-de-sorte-redis-password não encontrado no Key Vault' >&2
              exit 1
            fi

            echo "::add-mask::$password"
            echo "redis_password=$password" >> "$GITHUB_OUTPUT"
            echo "✅ Secret do Redis obtido com sucesso"

      - name: 🔴 Deploy Redis Stack (Swarm-Only)
        env:
          STACK_NAME: conexao-redis
          DOCKER_NETWORK_NAME: conexao-network-swarm
          HAS_KEYVAULT: ${{ needs.validate-and-build.outputs.has_keyvault }}
          REDIS_PASSWORD: ${{ steps.kv.outputs.redis_password }}
        run: |
          set -Eeuo pipefail
          compose_file="docker-compose.yml"
          secret_name="conexao-de-sorte-redis-password"
          has_keyvault="${HAS_KEYVAULT:-false}"
          password="${REDIS_PASSWORD:-}"

          echo "🚀 Iniciando deploy do Redis com Docker Swarm..."

          echo "🔍 Garantindo recursos básicos (rede, volume, secret)..."
          if ! docker network ls --format '{{.Name}}' | grep -Fxq "$DOCKER_NETWORK_NAME"; then
            echo "⚠️ Rede '$DOCKER_NETWORK_NAME' não encontrada - criando overlay attachable"
            docker network create --driver overlay --attachable "$DOCKER_NETWORK_NAME"
            echo "✅ Rede '$DOCKER_NETWORK_NAME' criada"
          else
            echo "✅ Rede '$DOCKER_NETWORK_NAME' já existe"
          fi

          volume_name="redis_data"
          if ! docker volume ls --format '{{.Name}}' | grep -Fxq "$volume_name"; then
            echo "⚠️ Volume '$volume_name' não encontrado - criando volume externo"
            docker volume create --name "$volume_name"
            echo "✅ Volume '$volume_name' criado"
          else
            echo "✅ Volume '$volume_name' já existe"
          fi

          # Remover stack existente se houver
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "🔄 Removendo stack existente '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"
            echo "⏳ Aguardando remoção completa da stack '$STACK_NAME'..."
            for _ in $(seq 1 36); do
              if ! docker stack ls | grep -q "$STACK_NAME"; then
                echo "✅ Stack '$STACK_NAME' removida"
                break
              fi
              sleep 5
            done
            if docker stack ls | grep -q "$STACK_NAME"; then
              echo "⚠️ Stack '$STACK_NAME' ainda está em processo de remoção"
            fi
          fi

          if [[ "$has_keyvault" == "true" ]]; then
            if [[ -z "$password" ]]; then
              echo "❌ Segredo do Redis não recebido do Key Vault"
              exit 1
            fi

            tmp_file=$(mktemp)
            cleanup() { rm -f "$tmp_file"; }
            trap cleanup EXIT
            printf '%s' "$password" > "$tmp_file"

            if docker secret ls --format '{{.Name}}' | grep -Fxq "$secret_name"; then
              echo "♻️ Atualizando secret '$secret_name'"
              docker secret rm "$secret_name"
              # aguardar remoção para evitar conflitos
              for _ in $(seq 1 12); do
                if ! docker secret ls --format '{{.Name}}' | grep -Fxq "$secret_name"; then
                  break
                fi
                sleep 2
              done
            else
              echo "🆕 Criando secret '$secret_name'"
            fi

            docker secret create "$secret_name" "$tmp_file"
            echo "✅ Secret '$secret_name' disponível no Swarm"
          else
            if docker secret ls --format '{{.Name}}' | grep -Fxq "$secret_name"; then
              echo "ℹ️ Utilizando secret existente '$secret_name'"
            else
              echo "❌ Secret '$secret_name' não encontrado no Swarm e Key Vault desabilitado"
              exit 1
            fi
          fi

          # Deploy da nova stack
          echo "🏗️ Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$compose_file" "$STACK_NAME"

          echo "⏰ Aguardando estabilização dos serviços Redis..."
          sleep 35

      - name: Healthcheck Redis (Multi-método)
        run: |
          echo "🔍 Validando saúde do Redis com health checks robustos..."

          # Aguardar até 3 minutos para Redis ficar disponível
          timeout=180
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            REDIS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)

            if [ -n "$REDIS_CONTAINER" ]; then
              echo "🔍 Testando health check do Redis... ($elapsed/$timeout segundos)"

              # Método 1: Comando nativo redis-cli ping
              if docker exec "$REDIS_CONTAINER" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                echo "✅ Redis health check passed (native command)"
                health_passed=true
                break
              fi

              # Método 2: Verificar logs de inicialização
              if docker logs "$REDIS_CONTAINER" 2>/dev/null | grep -q "Ready to accept connections\\|The server is now ready"; then
                echo "✅ Redis health check passed (logs validation)"
                health_passed=true
                break
              fi

              # Método 3: Verificar se porta está ativa
              if docker exec "$REDIS_CONTAINER" ss -tuln 2>/dev/null | grep -q ":6379"; then
                echo "✅ Redis health check passed (port active)"
                health_passed=true
                break
              fi

              echo "⏳ Redis ainda não está pronto... ($elapsed/$timeout segundos)"
            else
              echo "ℹ️ Status atual das tarefas Redis"
              docker service ps "${STACK_NAME}_redis" --no-trunc || true
              echo "⏳ Container Redis ainda não encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "⚠️ Redis health check não passou em $timeout segundos"
            echo "🔍 Verificando logs finais do Redis..."
            if [ -n "$REDIS_CONTAINER" ]; then
              echo "--- Últimos 30 logs do Redis ---"
              docker logs "$REDIS_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "💡 Nota: Redis pode estar funcionando mesmo com health check parcial"
            echo "💡 Verifique os logs acima para diagnóstico"
            exit 1
          else
            echo "✅ Redis health check concluído com sucesso!"
          fi

      - name: Connectivity Validation
        run: |
          echo "🔍 Validando conectividade do Redis..."

          # Verificar se o serviço está listado no Swarm
          if docker service ls | grep -q "${STACK_NAME}_redis"; then
            echo "✅ Serviço Redis encontrado no Swarm"
          else
            echo "❌ Serviço Redis não encontrado no Swarm"
            exit 1
          fi

          # Verificar se está na rede correta
          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q redis; then
            echo "✅ Redis conectado à rede overlay"
          else
            echo "⚠️ Redis pode não estar na rede overlay correta"
          fi

          # Verificar endpoints específicos
          REDIS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)
          if [ -n "$REDIS_CONTAINER" ]; then
            # Testar Redis port
            if docker exec "$REDIS_CONTAINER" ss -tuln 2>/dev/null | grep -q ":6379"; then
              echo "✅ Redis port ativo (porta 6379)"
            else
              echo "ℹ️ Redis port não detectado"
            fi
          fi

          echo "📊 Status final dos serviços:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

      - name: Traefik Health Monitor Validation
        run: |
          set -euo pipefail
          HEALTH_MONITOR_URL="https://traefik.conexaodesorte.com.br/health/service/redis"
          TIMEOUT_TOTAL=300
          INTERVAL=10
          elapsed=0
          last_response=""
          status=""

          while [ $elapsed -lt $TIMEOUT_TOTAL ]; do
            echo "🔎 Consultando Traefik (${elapsed}/${TIMEOUT_TOTAL}s)..."
            response=$(curl -sf --max-time 10 "$HEALTH_MONITOR_URL" 2>/dev/null || true)
            last_response="$response"

            if [[ -n "$response" ]]; then
              status=$(printf '%s' "$response" | python3 - <<'PY' 2>/dev/null || true
import json, sys
try:
    data = json.load(sys.stdin)
    print(data.get("status", ""))
except Exception:
    pass
PY
)
              status=${status//$'\n'/}
              echo "📊 Status reportado: ${status:-indefinido}"

              if [[ "$status" == "healthy" ]]; then
                echo "✅ Traefik confirmou Redis como healthy"
                exit 0
              fi
            else
              echo "⚠️ Traefik sem resposta nesta tentativa"
            fi

            sleep "$INTERVAL"
            elapsed=$((elapsed + INTERVAL))
          done

          echo "❌ Traefik nao confirmou Redis como healthy apos ${TIMEOUT_TOTAL}s"
          echo "📝 Ultima resposta recebida: ${last_response:-<sem resposta>}"
          exit 1
          echo "🔍 Status detalhado do serviço Redis:"
          docker service ps "${STACK_NAME}_redis" --no-trunc || true
