name: "üî¥ Redis Infrastructure ‚Äì CI/CD Pipeline (SIMPLE SUCCESS PATTERN)"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: redis-infrastructure

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-build:
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-zookeeper-infraestrutura ]
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - uses: actions/checkout@v4.3.0

      - name: üîé Validar identificadores Azure (vars)
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via secrets"
          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"
          # Key Vault opcional para Redis (infraestrutura simples)
          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
            echo '‚ÑπÔ∏è Key Vault n√£o configurado (Redis n√£o requer segredos complexos)'
          fi
          if [[ -z "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo '‚ÑπÔ∏è AZURE_KEYVAULT_ENDPOINT n√£o definido (usando endpoint padr√£o)'
          else
            echo '‚úÖ Endpoint customizado definido'
          fi

      - name: Ensure Python deps
        run: |
          set -Eeuo pipefail
          if ! command -v python3 >/dev/null 2>&1; then
            echo '‚ùå python3 n√£o est√° dispon√≠vel no runner self-hosted.' >&2
            exit 1
          fi
          python3 -c "import importlib.util, subprocess, sys; import importlib; spec = importlib.util.find_spec('yaml'); subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--user', 'PyYAML']) if spec is None else None"
          echo "‚úÖ Depend√™ncias Python dispon√≠veis"

      - name: üîê Azure Login (OIDC)
        if: ${{ steps.check_secrets.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: üìã Confirmar consumo m√≠nimo do Key Vault
        if: ${{ steps.check_secrets.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Job de valida√ß√£o n√£o consome segredos do Key Vault (lista vazia).'

      - name: Validate Docker Compose
        run: |
          # Validar sintaxe do docker-compose.yml
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: Security Validation
        run: |
          # Verificar se n√£o h√° hardcoded passwords
          if grep -r "defaultpass\|redisdefaultpassword" docker-compose.yml; then
            echo "‚ùå Found hardcoded Redis passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

          # Verificar fail-safe pattern
          if grep -q "FATAL.*refusing to start" docker-compose.yml; then
            echo "‚úÖ Fail-safe security pattern implemented"
          else
            echo "‚ö†Ô∏è Fail-safe pattern recommended but not critical"
          fi

          # Verificar exposi√ß√£o Redis (seguindo padr√£o RabbitMQ que funcionou)
          if grep -E "^\s*ports:" docker-compose.yml; then
            echo "‚ö†Ô∏è WARNING: Redis may have exposed ports - ensure firewall protection"
            echo "üí° Note: Following RabbitMQ success pattern (commit 66154f5)"
          else
            echo "‚úÖ No ports exposed - maximum security (overlay network only)"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: redis-configs
          path: |
            docker-compose.yml

  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [ self-hosted, Linux, X64, conexao, conexao-de-sorte-zookeeper-infraestrutura ]
    timeout-minutes: 15
    if: ${{ github.ref == 'refs/heads/main' }}
    permissions:
      contents: read
      id-token: write
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-redis
      COMPOSE_FILE: docker-compose.yml
    steps:
      - uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: redis-configs
          path: .

      - name: Get Key Vault secrets (Redis)
        id: kv
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        uses: azure/get-keyvault-secrets@v1
        with:
          keyvault: ${{ secrets.AZURE_KEYVAULT_NAME }}
          secrets: |
            conexao-de-sorte-redis-password

      - name: Preparar secrets do Redis
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          set -Eeuo pipefail
          password="${{ steps.kv.outputs.conexao-de-sorte-redis-password }}"
          if [[ -z "$password" ]]; then
            echo '‚ùå Segredos do Redis n√£o retornados pelo Key Vault'
            exit 1
          fi
          echo '‚úÖ Segredos do Redis obtidos do Key Vault'

      - name: üî¥ Deploy Redis Stack (Swarm-Only)
        env:
          STACK_NAME: conexao-redis
          COMPOSE_FILE: docker-compose.yml
        run: |
          echo "üöÄ Iniciando deploy do Redis com Docker Swarm..."

          # Remover stack existente se houver
          if docker stack ls | grep -q "$STACK_NAME"; then
            echo "üîÑ Removendo stack existente '$STACK_NAME'..."
            docker stack rm "$STACK_NAME"
            sleep 10
          fi

          # Deploy da nova stack
          echo "üèóÔ∏è Executando deploy da stack '$STACK_NAME'..."
          docker stack deploy -c "$COMPOSE_FILE" "$STACK_NAME"

          echo "‚è∞ Aguardando estabiliza√ß√£o dos servi√ßos Redis..."
          sleep 35

      - name: Healthcheck Redis (Multi-m√©todo)
        env:
          STACK_NAME: conexao-redis
        run: |
          echo "üîç Validando sa√∫de do Redis com health checks robustos..."

          # Aguardar at√© 3 minutos para Redis ficar dispon√≠vel
          timeout=180
          elapsed=0
          health_passed=false

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            REDIS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)

            if [ -n "$REDIS_CONTAINER" ]; then
              echo "üîç Testando health check do Redis... ($elapsed/$timeout segundos)"

              # M√©todo 1: Comando nativo redis-cli ping
              if docker exec "$REDIS_CONTAINER" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                echo "‚úÖ Redis health check passed (native command)"
                health_passed=true
                break
              fi

              # M√©todo 2: Verificar logs de inicializa√ß√£o
              if docker logs "$REDIS_CONTAINER" 2>/dev/null | grep -q "Ready to accept connections\\|The server is now ready"; then
                echo "‚úÖ Redis health check passed (logs validation)"
                health_passed=true
                break
              fi

              # M√©todo 3: Verificar se porta est√° ativa
              if docker exec "$REDIS_CONTAINER" ss -tuln 2>/dev/null | grep -q ":6379"; then
                echo "‚úÖ Redis health check passed (port active)"
                health_passed=true
                break
              fi

              echo "‚è≥ Redis ainda n√£o est√° pronto... ($elapsed/$timeout segundos)"
            else
              echo "‚è≥ Container Redis ainda n√£o encontrado... ($elapsed/$timeout segundos)"
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "‚ö†Ô∏è Redis health check n√£o passou em $timeout segundos"
            echo "üîç Verificando logs finais do Redis..."
            if [ -n "$REDIS_CONTAINER" ]; then
              echo "--- √öltimos 30 logs do Redis ---"
              docker logs "$REDIS_CONTAINER" --tail 30 2>/dev/null || true
              echo "--- Fim dos logs ---"
            fi
            echo "üí° Nota: Redis pode estar funcionando mesmo com health check parcial"
            echo "üí° Verifique os logs acima para diagn√≥stico"
            exit 1
          else
            echo "‚úÖ Redis health check conclu√≠do com sucesso!"
          fi

      - name: Connectivity Validation
        env:
          STACK_NAME: conexao-redis
        run: |
          echo "üîç Validando conectividade do Redis..."

          # Verificar se o servi√ßo est√° listado no Swarm
          if docker service ls | grep -q "${STACK_NAME}_redis"; then
            echo "‚úÖ Servi√ßo Redis encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado no Swarm"
            exit 1
          fi

          # Verificar se est√° na rede correta
          if docker network inspect conexao-network-swarm | grep -q redis; then
            echo "‚úÖ Redis conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Redis pode n√£o estar na rede overlay correta"
          fi

          # Verificar endpoints espec√≠ficos
          REDIS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)
          if [ -n "$REDIS_CONTAINER" ]; then
            # Testar Redis port
            if docker exec "$REDIS_CONTAINER" ss -tuln 2>/dev/null | grep -q ":6379"; then
              echo "‚úÖ Redis port ativo (porta 6379)"
            else
              echo "‚ÑπÔ∏è Redis port n√£o detectado"
            fi
          fi

          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"