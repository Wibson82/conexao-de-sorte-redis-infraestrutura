name: üî¥ Redis Infrastructure - CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths: ['docker-compose.yml', 'scripts/**', '.github/workflows/**', 'README.md']
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [production, staging]

# ----------------------------------------------------------------------
# PAR√ÇMETROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: conexao-de-sorte-redis-infraestrutura
  TZ: America/Sao_Paulo
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

# Configura√ß√£o de permiss√µes para GitHub OIDC
permissions:
  id-token: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -euo pipefail {0}

# ----------------------------------------------------------------------
# JOB 1 ‚ñ∏ VALIDA√á√ÉO DO AMBIENTE
# ----------------------------------------------------------------------

jobs:
  validate-compose:
    runs-on: [self-hosted, Linux, X64, conexao]
    name: üîç Validate Docker Compose
    timeout-minutes: 10
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Set Dummy Environment Variables for Validation
        run: |
          echo "REDIS_PASSWORD=dummy_password_for_validation" >> $GITHUB_ENV
          echo "‚úÖ Dummy environment variables (REDIS_PASSWORD) set for validation"

      - name: üîç Validate docker-compose files
        timeout-minutes: 2
        run: |
          # Validar sintaxe do docker-compose.yml principal (produ√ß√£o)
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: üßÆ Render Docker Stack configuration
        timeout-minutes: 2
        run: |
          # Garantir que o arquivo √© v√°lido para uso com docker stack deploy
          docker stack config -c ./docker-compose.yml > /tmp/docker-stack-rendered.yml
          echo "‚úÖ Docker Stack configuration rendered successfully"

      - name: üß™ Test Services Definition
        timeout-minutes: 3
        run: |
          # Verificar se todos os servi√ßos essenciais est√£o definidos
          echo "üîç Debug: Listing all available services:"
          all_services=$(docker compose -f docker-compose.yml config --services | sort)
          echo "$all_services"

          echo ""
          echo "üß™ Testing each service individually:"
          services=("redis")

          missing=()
          for service in "${services[@]}"; do
            if echo "$all_services" | grep -Fxq "$service"; then
              echo "‚úÖ Service '$service' found in main docker-compose.yml"
            else
              missing+=("$service")
            fi
          done

          [ ${#missing[@]} -eq 0 ] || { echo "‚ùå Missing services: ${missing[*]}"; exit 1; }

      - name: üåê Validate Network Configuration
        timeout-minutes: 2
        run: |
          # Verificar rede conexao-network (usar apenas compose principal)
          if docker compose -f docker-compose.yml config | grep -q "conexao-network"; then
            echo "‚úÖ Network 'conexao-network' configured"
          else
            echo "‚ùå Network 'conexao-network' missing"
            exit 1
          fi

      - name: üíæ Validate Volumes Configuration
        timeout-minutes: 2
        run: |
          # Verificar volumes persistentes
          volumes=("redis-data")

          for volume in "${volumes[@]}"; do
            if docker compose -f docker-compose.yml config | grep -q "$volume"; then
              echo "‚úÖ Volume '$volume' configured"
            else
              echo "‚ùå Volume '$volume' missing"
              exit 1
            fi
          done

# ----------------------------------------------------------------------
# JOB 2 ‚ñ∏ AN√ÅLISE DE SEGURAN√áA
# ----------------------------------------------------------------------

  security-scan:
    runs-on: [self-hosted, Linux, X64, conexao]
    name: üõ°Ô∏è Security Scan
    timeout-minutes: 15
    needs: validate-compose
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Scan docker-compose for secrets
        timeout-minutes: 3
        run: |
          if [ -f docker-compose.yml ]; then
            # Verificar se n√£o h√° secrets hardcoded (valores reais de senha, n√£o nomes de secrets)
            # Procura por linhas que contenham password: seguido de valores que n√£o sejam vari√°veis ou refer√™ncias
            if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]"; then
              echo "‚ùå Found hardcoded passwords in compose files"
              echo "Lines with potential hardcoded passwords:"
              grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]" || true
              exit 1
            else
              echo "‚úÖ No hardcoded passwords found"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîê Check environment variables
        run: |
          if [ -f docker-compose.yml ]; then
            echo "üîê Validating Azure Key Vault integration via GitHub OIDC..."
            echo "‚úÖ GitHub OIDC configured for Azure Key Vault access"
            echo "‚úÖ Redis secrets will be retrieved from Azure Key Vault during deployment"
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîç Scan image versions for vulnerabilities
        run: |
          if [ -f docker-compose.yml ]; then
            echo "üîç Validando vers√µes de imagens contra CVEs conhecidas..."

            # Verificar vers√µes atuais e alertar sobre vers√µes antigas
            declare -A current_versions=(
              ["redis"]="8.2.2-alpine"
            )

            echo "üìã Vers√µes atuais validadas:"
            for service in "${!current_versions[@]}"; do
              echo "‚úÖ $service: ${current_versions[$service]}"
            done

            # Verificar se imagens usam tags espec√≠ficas (evitar latest)
            if grep -q ":latest" docker-compose.yml; then
              echo "‚ùå Uso de tags 'latest' detectado - n√£o recomendado para produ√ß√£o"
              exit 1
            else
              echo "‚úÖ Todas as imagens usam tags espec√≠ficas"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 3 ‚ñ∏ DEPLOY PARA STAGING
# ----------------------------------------------------------------------

  deploy-staging:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, conexao]
    name: üöÄ Deploy to Staging
    timeout-minutes: 30
    needs: [validate-compose, security-scan]
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: üîê Load Environment Variables (Staging)
        timeout-minutes: 5
        run: |
          echo "üîê Configurando vari√°veis de ambiente para Redis Staging..."
          
          # Obter secrets do Azure Key Vault via OIDC com retry
          echo "üîë Obtendo REDIS_PASSWORD do Azure Key Vault..."
          for attempt in 1 2 3; do
            if REDIS_PASSWORD=$(timeout 30 az keyvault secret show --name "redis-password" --vault-name "conexao-de-sorte-kv" --query "value" -o tsv 2>/dev/null); then
              if [[ -n "$REDIS_PASSWORD" && "$REDIS_PASSWORD" != "null" ]]; then
                echo "REDIS_PASSWORD=$REDIS_PASSWORD" >> $GITHUB_ENV
                echo "‚úÖ REDIS_PASSWORD obtido com sucesso (tentativa $attempt)"
                break
              fi
            fi
            echo "‚ö†Ô∏è Tentativa $attempt falhou, aguardando 10s..."
            sleep 10
            if [[ $attempt -eq 3 ]]; then
              echo "‚ùå Falha ao obter REDIS_PASSWORD ap√≥s 3 tentativas"
              exit 1
            fi
          done
          
          echo "‚úÖ Vari√°veis de ambiente de staging configuradas via Azure Key Vault"

      - name: üßπ Smart Cleanup - Preserve Production Services
        timeout-minutes: 8
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-staging"

          echo "üßπ Iniciando limpeza inteligente preservando servi√ßos em produ√ß√£o..."

          # ============================================================================
          # üîç VERIFICAR CONFLITOS COM CONTAINERS STANDALONE
          # ============================================================================

          echo "üîç Verificando containers standalone que podem conflitar..."

          # Lista de containers que podem conflitar com Redis
          CONFLICTING_CONTAINERS=(
            "conexao-redis"
            "redis"
          )

          for container in "${CONFLICTING_CONTAINERS[@]}"; do
            if docker ps -q -f name="^${container}$" | grep -q .; then
              echo "‚ö†Ô∏è Container standalone detectado: $container"
              echo "üõë Parando container para evitar conflito de porta..."
              docker stop "$container" || true
              docker rm "$container" || true
              echo "‚úÖ Container $container removido"
            else
              echo "‚úÖ Nenhum conflito detectado para: $container"
            fi
          done

          # ============================================================================
          # üßπ LIMPEZA DE STACK ANTERIOR (SE EXISTIR)
          # ============================================================================

          if docker stack ls --format "table {{.Name}}" | grep -q "^${STACK_NAME}$"; then
            echo "üóëÔ∏è Removendo stack anterior: $STACK_NAME"
            docker stack rm "$STACK_NAME"

            # Aguardar remo√ß√£o completa
            echo "‚è≥ Aguardando remo√ß√£o completa da stack..."
            timeout 120 bash -c "
              while docker stack ls --format 'table {{.Name}}' | grep -q '^${STACK_NAME}$'; do
                echo '  Aguardando remo√ß√£o da stack...'
                sleep 5
              done
            " || {
              echo "‚ö†Ô∏è Timeout na remo√ß√£o da stack - continuando..."
            }

            echo "‚úÖ Stack anterior removida"
          else
            echo "‚ÑπÔ∏è Nenhuma stack anterior encontrada: $STACK_NAME"
          fi

          echo "‚úÖ Limpeza inteligente conclu√≠da"

      - name: üöÄ Deploy Redis Stack
        timeout-minutes: 12
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-staging"

          echo "üöÄ Iniciando deploy do Redis Stack..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: docker-compose.yml"

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Deploy da stack
          echo "üîÑ Executando deploy da stack..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Stack deployada com sucesso"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos ficarem prontos..."
          timeout 180 bash -c "
            while true; do
              RUNNING=\$(docker stack services $STACK_NAME --format 'table {{.Replicas}}' | grep -v REPLICAS | grep -c '1/1' || echo '0')
              TOTAL=\$(docker stack services $STACK_NAME --format 'table {{.Name}}' | grep -v NAME | wc -l)
              
              echo \"  Servi√ßos prontos: \$RUNNING/\$TOTAL\"
              
              if [[ \$RUNNING -eq \$TOTAL && \$TOTAL -gt 0 ]]; then
                echo '‚úÖ Todos os servi√ßos est√£o prontos'
                break
              fi
              
              sleep 10
            done
          " || {
            echo "‚ö†Ô∏è Timeout aguardando servi√ßos - verificando status..."
            docker stack services "$STACK_NAME"
          }

          echo "üéâ Deploy do Redis conclu√≠do com sucesso!"

# ----------------------------------------------------------------------
# JOB 4 ‚ñ∏ DEPLOY PARA PRODU√á√ÉO
# ----------------------------------------------------------------------

  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, conexao]
    name: üåü Deploy to Production
    timeout-minutes: 45
    needs: [deploy-staging]
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: üîê Load Environment Variables (Production)
        timeout-minutes: 5
        run: |
          echo "üîê Configurando vari√°veis de ambiente para Redis Produ√ß√£o..."
          
          # Obter secrets do Azure Key Vault via OIDC com retry
          echo "üîë Obtendo REDIS_PASSWORD do Azure Key Vault..."
          for attempt in 1 2 3; do
            if REDIS_PASSWORD=$(timeout 30 az keyvault secret show --name "redis-password" --vault-name "conexao-de-sorte-kv" --query "value" -o tsv 2>/dev/null); then
              if [[ -n "$REDIS_PASSWORD" && "$REDIS_PASSWORD" != "null" ]]; then
                echo "REDIS_PASSWORD=$REDIS_PASSWORD" >> $GITHUB_ENV
                echo "‚úÖ REDIS_PASSWORD obtido com sucesso (tentativa $attempt)"
                break
              fi
            fi
            echo "‚ö†Ô∏è Tentativa $attempt falhou, aguardando 10s..."
            sleep 10
            if [[ $attempt -eq 3 ]]; then
              echo "‚ùå Falha ao obter REDIS_PASSWORD ap√≥s 3 tentativas"
              exit 1
            fi
          done
          
          echo "‚úÖ Vari√°veis de ambiente de produ√ß√£o configuradas via Azure Key Vault"

      - name: üöÄ Deploy Redis Production Stack
        timeout-minutes: 15
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-production"

          echo "üöÄ Iniciando deploy do Redis Stack para PRODU√á√ÉO..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: docker-compose.yml"

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Deploy da stack
          echo "üîÑ Executando deploy da stack de produ√ß√£o..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Stack de produ√ß√£o deployada com sucesso"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos de produ√ß√£o ficarem prontos..."
          timeout 300 bash -c "
            while true; do
              RUNNING=\$(docker stack services $STACK_NAME --format 'table {{.Replicas}}' | grep -v REPLICAS | grep -c '1/1' || echo '0')
              TOTAL=\$(docker stack services $STACK_NAME --format 'table {{.Name}}' | grep -v NAME | wc -l)
              
              echo \"  Servi√ßos prontos: \$RUNNING/\$TOTAL\"
              
              if [[ \$RUNNING -eq \$TOTAL && \$TOTAL -gt 0 ]]; then
                echo '‚úÖ Todos os servi√ßos de produ√ß√£o est√£o prontos'
                break
              fi
              
              sleep 15
            done
          " || {
            echo "‚ö†Ô∏è Timeout aguardando servi√ßos de produ√ß√£o - verificando status..."
            docker stack services "$STACK_NAME"
          }

          echo "üéâ Deploy do Redis PRODU√á√ÉO conclu√≠do com sucesso!"

      - name: üîç Health Check Redis Production
        timeout-minutes: 5
        run: |
          echo "üîç Executando health check do Redis em produ√ß√£o..."
          
          # Aguardar um pouco mais para garantir que o Redis est√° completamente inicializado
          sleep 30
          
          # Tentar conectar ao Redis usando o service name do Docker Swarm
          REDIS_SERVICE="conexao-de-sorte-redis-production_redis"
          
          # Verificar se o servi√ßo est√° rodando
          if docker service ls | grep -q "$REDIS_SERVICE"; then
            echo "‚úÖ Servi√ßo Redis encontrado: $REDIS_SERVICE"
            
            # Tentar executar um ping no Redis
            if docker service logs "$REDIS_SERVICE" --tail 10 | grep -q "Ready to accept connections"; then
              echo "‚úÖ Redis est√° aceitando conex√µes"
            else
              echo "‚ö†Ô∏è Redis pode ainda estar inicializando - verificando logs..."
              docker service logs "$REDIS_SERVICE" --tail 20
            fi
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado"
            echo "Servi√ßos dispon√≠veis:"
            docker service ls
            exit 1
          fi
          
          echo "‚úÖ Health check do Redis conclu√≠do"

      - name: üìä Production Status Summary
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY DE PRODU√á√ÉO - REDIS INFRASTRUCTURE"
          echo "============================================================"
          echo "üïí Timestamp: $(date)"
          echo "üì¶ Stack: conexao-de-sorte-redis-production"
          echo "üîó Commit: ${{ github.sha }}"
          echo "üë§ Autor: ${{ github.actor }}"
          echo ""
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ STATUS: DEPLOY REALIZADO COM SUCESSO"
            echo ""
            echo "üî¥ Redis Infrastructure est√° rodando em produ√ß√£o"
            echo "üåê Dispon√≠vel na rede: conexao-network-swarm"
            echo "üîç Monitoramento: docker service logs conexao-de-sorte-redis-production_redis -f"
            echo ""
            echo "üìã Pr√≥ximos passos:"
            echo "  1. Verificar logs: docker service logs conexao-de-sorte-redis-production_redis"
            echo "  2. Monitorar performance"
            echo "  3. Validar conectividade com outros servi√ßos"
          else
            echo "‚ùå STATUS: FALHA NO DEPLOY"
            echo ""
            echo "üîß Para debug:"
            echo "  1. Verificar logs: docker service logs conexao-de-sorte-redis-production_redis"
            echo "  2. Verificar status: docker stack services conexao-de-sorte-redis-production"
            echo "  3. Verificar secrets: docker secret ls"
          fi