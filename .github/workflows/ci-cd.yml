name: üî¥ Redis Infrastructure - CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths: ['docker-compose.yml', 'scripts/**', '.github/workflows/**', 'README.md']
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [production, staging]

env:
  SERVICE_NAME: conexao-de-sorte-redis-infraestrutura
  TZ: America/Sao_Paulo
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}

# Configura√ß√£o de permiss√µes para GitHub OIDC
permissions:
  id-token: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -euo pipefail {0}

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4.3.0

      - name: Install dependencies
        run: |
          # Instalar apenas depend√™ncias b√°sicas
          sudo apt-get update >/dev/null 2>&1
          sudo apt-get install -y python3 python3-yaml >/dev/null 2>&1
          echo "‚úÖ Depend√™ncias b√°sicas instaladas"

      - name: Validate Redis Configs
        timeout-minutes: 2
        run: |
          # Valida√ß√£o simples de sintaxe YAML (sem Docker)
          echo "üîç Validando sintaxe YAML do docker-compose.yml..."

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Valida√ß√£o b√°sica de sintaxe YAML usando Python
          python3 -c "
          import yaml
          import sys
          try:
              with open('docker-compose.yml', 'r') as f:
                  data = yaml.safe_load(f)
              print('‚úÖ YAML syntax is valid')

              # Verificar estrutura b√°sica
              if 'services' not in data:
                  print('‚ùå Se√ß√£o services n√£o encontrada')
                  sys.exit(1)

              if 'redis' not in data['services']:
                  print('‚ùå Servi√ßo redis n√£o encontrado')
                  sys.exit(1)

              print('‚úÖ Estrutura Redis v√°lida')

          except yaml.YAMLError as e:
              print(f'‚ùå YAML syntax error: {e}')
              sys.exit(1)
          except Exception as e:
              print(f'‚ùå Error: {e}')
              sys.exit(1)
          "

          echo "‚úÖ Valida√ß√£o Redis conclu√≠da com sucesso"

      - name: Security Validation
        run: |
          # Verificar se n√£o h√° secrets hardcoded
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]"; then
            echo "‚ùå Found hardcoded passwords in compose files"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi

          # Verificar se imagens usam tags espec√≠ficas
          if grep -q ":latest" docker-compose.yml; then
            echo "‚ùå Uso de tags 'latest' detectado - n√£o recomendado para produ√ß√£o"
            exit 1
          else
            echo "‚úÖ Todas as imagens usam tags espec√≠ficas"
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.5.0
        with:
          name: redis-configs
          path: |
            docker-compose.yml
            .env.ci

  deploy-production:
    needs: validate-and-build
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-redis-infraestrutura]
    timeout-minutes: 25
    if: github.ref == 'refs/heads/main'
    permissions:
      id-token: write
      contents: read
    env:
      DOCKER_NETWORK_NAME: conexao-network-swarm
      STACK_NAME: conexao-redis
      COMPOSE_FILE: docker-compose.yml
      TZ: America/Sao_Paulo
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
    steps:
      - uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: redis-configs
          path: .

      - name: üîê Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: üîë Load Redis Secrets from Azure Key Vault
        run: |
          echo "üîê Carregando secrets do Redis do Azure Key Vault..."

          # Testar conectividade Azure Key Vault primeiro
          if timeout 10 az keyvault secret show --name "conexao-de-sorte-redis-password" --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --query "value" -o tsv >/dev/null 2>&1; then
            echo "‚úÖ Azure Key Vault acess√≠vel"

            # Secrets existentes no Azure Key Vault
            REDIS_PASSWORD=$(az keyvault secret show --name "conexao-de-sorte-redis-password" --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --query "value" -o tsv)
            REDIS_DATABASE=$(az keyvault secret show --name "conexao-de-sorte-redis-database" --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --query "value" -o tsv)
            REDIS_HOST=$(az keyvault secret show --name "conexao-de-sorte-redis-host" --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --query "value" -o tsv)
            REDIS_PORT=$(az keyvault secret show --name "conexao-de-sorte-redis-port" --vault-name "${{ env.AZURE_KEYVAULT_NAME }}" --query "value" -o tsv)

            echo "‚úÖ Redis secrets carregados do Azure Key Vault"
          else
            echo "‚ö†Ô∏è Azure Key Vault inacess√≠vel - usando configura√ß√µes padr√£o"

            # Fallback para configura√ß√µes padr√£o Redis
            REDIS_PASSWORD="redisdefaultpassword"
            REDIS_DATABASE="0"
            REDIS_HOST="redis"
            REDIS_PORT="6379"

            echo "‚ö†Ô∏è Usando configura√ß√µes padr√£o Redis"
          fi

          # Adicionar ao ambiente
          echo "REDIS_PASSWORD=$REDIS_PASSWORD" >> $GITHUB_ENV
          echo "REDIS_HOST=$REDIS_HOST" >> $GITHUB_ENV
          echo "REDIS_PORT=$REDIS_PORT" >> $GITHUB_ENV
          echo "REDIS_DATABASE=$REDIS_DATABASE" >> $GITHUB_ENV

      - name: üîê Create Docker Secrets
        run: |
          echo "üîê Criando Docker Secrets para Redis..."

          # Remover secrets antigos para garantir uso dos novos valores do Azure Key Vault
          echo "üóëÔ∏è Removendo secrets Redis antigos..."
          docker secret rm conexao-de-sorte-redis-password 2>/dev/null || echo "‚ÑπÔ∏è Secret n√£o existia"

          # Approach definitivo: usar set +e para ignorar exit codes
          set +e

          echo "üìù Criando secret conexao-de-sorte-redis-password..."
          echo "$REDIS_PASSWORD" | docker secret create conexao-de-sorte-redis-password -
          if [ $? -eq 0 ]; then
            echo "‚úÖ Secret conexao-de-sorte-redis-password criado"
          else
            echo "‚ÑπÔ∏è Secret conexao-de-sorte-redis-password j√° existe - reutilizando"
          fi

          set -e

          echo "‚úÖ Docker Secrets verificados/criados com sucesso"

      - name: üîç Validate Docker Secrets
        run: |
          echo "üîç Validando Docker Secrets criados..."

          # Validar secret da senha
          if docker secret ls | grep -q "conexao-de-sorte-redis-password"; then
            echo "‚úÖ Secret conexao-de-sorte-redis-password encontrado"
          else
            echo "‚ùå Secret conexao-de-sorte-redis-password n√£o encontrado"
            exit 1
          fi

          echo "‚úÖ Valida√ß√£o de secrets conclu√≠da"

      - name: üîß Ensure Required Docker Resources
        timeout-minutes: 3
        run: |
          echo "üîß Verificando/criando recursos Docker necess√°rios..."

          # Criar volume Redis se n√£o existir
          if ! docker volume ls | grep -q "redis_data"; then
            echo "üì¶ Criando volume redis_data..."
            docker volume create redis_data
          else
            echo "‚úÖ Volume redis_data j√° existe"
          fi

          # Verificar rede Swarm
          if ! docker network ls | grep -q "conexao-network-swarm"; then
            echo "üåê Criando rede Swarm..."
            docker network create -d overlay --attachable conexao-network-swarm
          else
            echo "‚úÖ Rede conexao-network-swarm j√° existe"
          fi

          echo "‚úÖ Recursos Docker verificados/criados"

      - name: üöÄ Deploy Redis Production Stack
        env:
          STACK_NAME: conexao-redis
          COMPOSE_FILE: docker-compose.yml
        run: |
          echo "üöÄ Iniciando deploy do Redis Stack para PRODU√á√ÉO..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: $COMPOSE_FILE"

          # Verificar se arquivo existe
          if [[ ! -f $COMPOSE_FILE ]]; then
            echo "‚ùå Arquivo $COMPOSE_FILE n√£o encontrado"
            exit 1
          fi

          # Limpeza completa de containers/volumes antigos para deploy limpo
          echo "üßπ Limpeza completa: removendo containers e volumes Redis antigos..."

          # Parar e remover stack
          docker stack rm "$STACK_NAME" 2>/dev/null || echo "‚ÑπÔ∏è Stack n√£o existia"

          # Aguardar remo√ß√£o da stack
          sleep 15

          # Remover containers √≥rf√£os Redis espec√≠ficos
          echo "üóëÔ∏è Removendo containers Redis √≥rf√£os..."
          docker ps -a --filter "name=redis" --filter "name=conexao-redis" -q | xargs -r docker rm -f || echo "‚ÑπÔ∏è Nenhum container Redis √≥rf√£o"

          # Limpar imagens Redis n√£o utilizadas
          echo "üñºÔ∏è Limpando imagens Redis n√£o utilizadas..."
          docker images --filter "reference=redis:*" --filter "dangling=false" -q | head -3 | tail -n +2 | xargs -r docker rmi || echo "‚ÑπÔ∏è Nenhuma imagem Redis antiga"

          # Aguardar limpeza completa
          echo "‚è≥ Aguardando limpeza completa..."
          sleep 15

          # Deploy da stack limpa
          echo "üîÑ Executando deploy limpo da stack de produ√ß√£o..."
          docker stack deploy -c $COMPOSE_FILE "$STACK_NAME"

          echo "‚úÖ Stack de produ√ß√£o deployada com sucesso (deploy limpo)"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos de produ√ß√£o ficarem prontos..."

          for i in {1..12}; do
            # Simplificar para evitar problemas de parsing
            SERVICES_STATUS=$(docker stack services $STACK_NAME --format '{{.Replicas}}' 2>/dev/null || echo "0/1")

            echo "  Tentativa $i/12 - Status: $SERVICES_STATUS"

            if echo "$SERVICES_STATUS" | grep -q "1/1"; then
              echo '‚úÖ Todos os servi√ßos de produ√ß√£o est√£o prontos'
              break
            fi

            if [[ $i -eq 12 ]]; then
              echo "‚ö†Ô∏è Timeout aguardando servi√ßos - verificando status final..."
              docker stack services "$STACK_NAME"
              echo "üîç Logs do servi√ßo para diagn√≥stico:"
              docker service logs conexao-redis_redis --tail 20 || echo "‚ùå Erro ao obter logs"
            fi

            sleep 15
          done

          echo "üéâ Deploy do Redis PRODU√á√ÉO conclu√≠do com sucesso!"

      - name: üîç Health Check Redis
        env:
          STACK_NAME: conexao-redis
        run: |
          echo "üîç Executando health check do Redis em produ√ß√£o..."

          # Aguardar inicializa√ß√£o
          sleep 30

          # Verificar servi√ßo Redis
          REDIS_SERVICE="conexao-redis_redis"

          if docker service ls | grep -q "$REDIS_SERVICE"; then
            echo "‚úÖ Servi√ßo Redis encontrado: $REDIS_SERVICE"

            # Verificar logs do Redis
            if docker service logs "$REDIS_SERVICE" --tail 10 | grep -q "Ready to accept connections"; then
              echo "‚úÖ Redis est√° aceitando conex√µes"
            else
              echo "‚ö†Ô∏è Redis pode ainda estar inicializando - verificando logs..."
              docker service logs "$REDIS_SERVICE" --tail 20
            fi
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado"
            echo "Servi√ßos dispon√≠veis:"
            docker service ls
            exit 1
          fi

          echo "‚úÖ Health check do Redis conclu√≠do"

      - name: üìä Production Status Summary
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY DE PRODU√á√ÉO - REDIS INFRASTRUCTURE"
          echo "============================================================"
          echo "üïí Timestamp: $(date)"
          echo "üì¶ Stack: conexao-redis"
          echo "üîó Commit: ${{ github.sha }}"
          echo "üë§ Autor: ${{ github.actor }}"
          echo ""

          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ STATUS: DEPLOY REALIZADO COM SUCESSO"
            echo ""
            echo "üî¥ Redis Infrastructure est√° rodando em produ√ß√£o"
            echo "üåê Dispon√≠vel na rede: conexao-network-swarm"
            echo "üîç Monitoramento: docker service logs conexao-redis_redis -f"
            echo ""
            echo "üìã Pr√≥ximos passos:"
            echo "  1. Verificar logs: docker service logs conexao-redis_redis"
            echo "  2. Monitorar performance"
            echo "  3. Validar conectividade com outros servi√ßos"
          else
            echo "‚ùå STATUS: FALHA NO DEPLOY"
            echo ""
            echo "üîß Para debug:"
            echo "  1. Verificar logs: docker service logs conexao-redis_redis"
            echo "  2. Verificar status: docker stack services conexao-redis"
            echo "  3. Verificar secrets: docker secret ls"
          fi