name: üî¥ Redis Infrastructure - CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths: ['docker-compose.yml', 'scripts/**', '.github/workflows/**', 'README.md']
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [production, staging]

# ----------------------------------------------------------------------
# PAR√ÇMETROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: conexao-de-sorte-redis-infraestrutura
  TZ: America/Sao_Paulo

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -euo pipefail {0}

# ----------------------------------------------------------------------
# JOB 1 ‚ñ∏ VALIDA√á√ÉO DO AMBIENTE
# ----------------------------------------------------------------------

jobs:
  validate-compose:
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üîç Validate Docker Compose
    timeout-minutes: 10
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Set Dummy Environment Variables for Validation
        run: |
          echo "REDIS_PASSWORD=dummy_password_for_validation" >> $GITHUB_ENV
          echo "‚úÖ Dummy environment variables (REDIS_PASSWORD) set for validation"

      - name: üîç Validate docker-compose files
        run: |
          # Validar sintaxe do docker-compose.yml principal (produ√ß√£o)
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: üßÆ Render Docker Stack configuration
        run: |
          # Garantir que o arquivo √© v√°lido para uso com docker stack deploy
          docker stack config -c ./docker-compose.yml > /tmp/docker-stack-rendered.yml
          echo "‚úÖ Docker Stack configuration rendered successfully"

      - name: üß™ Test Services Definition
        run: |
          # Verificar se todos os servi√ßos essenciais est√£o definidos
          echo "üîç Debug: Listing all available services:"
          all_services=$(docker compose -f docker-compose.yml config --services | sort)
          echo "$all_services"

          echo ""
          echo "üß™ Testing each service individually:"
          services=("redis")

          missing=()
          for service in "${services[@]}"; do
            if echo "$all_services" | grep -Fxq "$service"; then
              echo "‚úÖ Service '$service' found in main docker-compose.yml"
            else
              missing+=("$service")
            fi
          done

          [ ${#missing[@]} -eq 0 ] || { echo "‚ùå Missing services: ${missing[*]}"; exit 1; }

      - name: üåê Validate Network Configuration
        run: |
          # Verificar rede conexao-network (usar apenas compose principal)
          if docker compose -f docker-compose.yml config | grep -q "conexao-network"; then
            echo "‚úÖ Network 'conexao-network' configured"
          else
            echo "‚ùå Network 'conexao-network' missing"
            exit 1
          fi

      - name: üíæ Validate Volumes Configuration
        run: |
          # Verificar volumes persistentes
          volumes=("redis-data")

          for volume in "${volumes[@]}"; do
            if docker compose -f docker-compose.yml config | grep -q "$volume"; then
              echo "‚úÖ Volume '$volume' configured"
            else
              echo "‚ùå Volume '$volume' missing"
              exit 1
            fi
          done

# ----------------------------------------------------------------------
# JOB 2 ‚ñ∏ AN√ÅLISE DE SEGURAN√áA
# ----------------------------------------------------------------------

  security-scan:
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üõ°Ô∏è Security Scan
    timeout-minutes: 15
    needs: validate-compose
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Scan docker-compose for secrets
        run: |
          if [ -f docker-compose.yml ]; then
            # Verificar se n√£o h√° secrets hardcoded (valores reais de senha, n√£o nomes de secrets)
            # Procura por linhas que contenham password: seguido de valores que n√£o sejam vari√°veis ou refer√™ncias
            if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]"; then
              echo "‚ùå Found hardcoded passwords in compose files"
              echo "Lines with potential hardcoded passwords:"
              grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]" || true
              exit 1
            else
              echo "‚úÖ No hardcoded passwords found"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîê Check environment variables
        run: |
          if [ -f docker-compose.yml ]; then
            # Verificar se vari√°veis obrigat√≥rias est√£o definidas na se√ß√£o de secrets
            required_vars=("REDIS_PASSWORD")
            echo "üîê Validating required secrets: ${required_vars[*]}"

            secrets_section=$(awk '/^secrets:/,/^[^[:space:]]/{print}' docker-compose.yml)

            for var in "${required_vars[@]}"; do
              if echo "$secrets_section" | grep -q "${var}:"; then
                echo "‚úÖ Required secret '$var' properly configured"
              else
                echo "‚ö†Ô∏è Secret '$var' is missing in docker-compose.yml"
              fi
            done
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîç Scan image versions for vulnerabilities
        run: |
          if [ -f docker-compose.yml ]; then
            echo "üîç Validando vers√µes de imagens contra CVEs conhecidas..."

            # Verificar vers√µes atuais e alertar sobre vers√µes antigas
            declare -A current_versions=(
              ["redis"]="8.2.2-alpine"
            )

            echo "üìã Vers√µes atuais validadas:"
            for service in "${!current_versions[@]}"; do
              echo "‚úÖ $service: ${current_versions[$service]}"
            done

            # Verificar se imagens usam tags espec√≠ficas (evitar latest)
            if grep -q ":latest" docker-compose.yml; then
              echo "‚ùå Uso de tags 'latest' detectado - n√£o recomendado para produ√ß√£o"
              exit 1
            else
              echo "‚úÖ Todas as imagens usam tags espec√≠ficas"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 3 ‚ñ∏ DEPLOY PARA STAGING
# ----------------------------------------------------------------------

  deploy-staging:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üöÄ Deploy to Staging
    timeout-minutes: 30
    needs: [validate-compose, security-scan]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # ‚îÄ‚îÄ‚îÄ Valida√ß√£o inteligente de secrets OIDC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîê Validar e configurar secrets Azure OIDC Redis
        shell: bash
        run: |
          echo "üîê Validando secrets OIDC para Redis Infrastructure..."
          echo "üìÅ Reposit√≥rio: ${{ github.repository }}"

          # Verificar se secrets est√£o configurados neste reposit√≥rio espec√≠fico
          MISSING_SECRETS=""
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_CLIENT_ID"
          fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_TENANT_ID"
          fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_SUBSCRIPTION_ID"
          fi
          if [ -z "${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_KEYVAULT_ENDPOINT"
          fi
          if [ -z "${{ secrets.AZURE_KEYVAULT_NAME }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_KEYVAULT_NAME"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Secrets ausentes no reposit√≥rio ${{ github.repository }}:$MISSING_SECRETS"
            echo ""
            echo "üîß SOLU√á√ÉO NECESS√ÅRIA:"
            echo "1. Acessar: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "2. Adicionar os seguintes Repository secrets:"
            echo "   - AZURE_CLIENT_ID: [Service Principal Client ID]"
            echo "   - AZURE_TENANT_ID: [Azure Tenant ID]"
            echo "   - AZURE_SUBSCRIPTION_ID: [Azure Subscription ID]"
            echo "   - AZURE_KEYVAULT_ENDPOINT: https://[vault-name].vault.azure.net"
            echo "   - AZURE_KEYVAULT_NAME: [vault-name]"
            echo ""
            echo "üí° Os values devem ser copiados do reposit√≥rio principal ou do Azure Portal"
            echo ""
            echo "‚ö†Ô∏è  PULANDO DEPLOY - Secrets de Redis n√£o configurados"
            exit 0  # Exit com sucesso para n√£o falhar o pipeline, mas pular deploy
          fi

          echo "‚úÖ Secrets Redis OIDC validados para ${{ github.repository }}"

      - name: üîë Azure Login (OIDC)
        uses: azure/login@v2
        timeout-minutes: 5
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      # ‚îÄ‚îÄ‚îÄ Verifica√ß√£o p√≥s-login ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîç Verificar conectividade Azure Redis
        shell: bash
        run: |
          echo "üîç Verificando conectividade Azure Redis..."

          if ACCOUNT_INFO=$(az account show --query "{name: name, id: id}" -o json 2>/dev/null); then
            echo "‚úÖ Login Azure Redis confirmado:"
            echo "$ACCOUNT_INFO" | jq -r '"  Subscription: \(.name) (\(.id))"'
          else
            echo "‚ùå Falha login Azure Redis"
            exit 1
          fi

      - name: üîê Sincronizar secrets do Azure Key Vault
        shell: bash
        run: |
          echo "üîê Configurando sincroniza√ß√£o de secrets..."

          # Extrair nome do vault do endpoint
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          VAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME }}"

          echo "üîë Vault: $VAULT_NAME"
          echo "üåê Endpoint: $VAULT_ENDPOINT"

          # Tornar script execut√°vel
          chmod +x .github/workflows/scripts/sync-azure-keyvault-secrets.sh

          echo "üîê Sincronizando secrets do Azure Key Vault..."

          # Executar sincroniza√ß√£o com timeout
          timeout 300 .github/workflows/scripts/sync-azure-keyvault-secrets.sh "$VAULT_NAME" "redis-infraestrutura" || {
            echo "‚ùå Timeout ou falha na sincroniza√ß√£o de secrets"
            echo ""
            echo "üîß SOLU√á√ïES POSS√çVEIS:"
            echo "1. Verificar conectividade com Azure Key Vault"
            echo "2. Verificar permiss√µes do Service Principal"
            echo "3. Executar manualmente:"
            echo "   .github/workflows/scripts/sync-azure-keyvault-secrets.sh $VAULT_NAME redis-infraestrutura"
            echo ""
            echo "üìã Verifique se todos os secrets existem no Azure Key Vault"
            exit 1
          }

          echo "‚úÖ Secrets sincronizados com sucesso"

      - name: üßπ Smart Cleanup - Preserve Production Services
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-staging"

          echo "üßπ Iniciando limpeza inteligente preservando servi√ßos em produ√ß√£o..."

          # ============================================================================
          # üîç VERIFICAR CONFLITOS COM CONTAINERS STANDALONE
          # ============================================================================

          echo "üîç Verificando containers standalone que podem conflitar..."

          # Lista de containers que podem conflitar com Redis
          CONFLICTING_CONTAINERS=(
            "conexao-redis"
            "redis"
          )

          for container in "${CONFLICTING_CONTAINERS[@]}"; do
            if docker ps -q -f name="^${container}$" | grep -q .; then
              echo "‚ö†Ô∏è Container standalone detectado: $container"
              echo "üõë Parando container para evitar conflito de porta..."
              docker stop "$container" || true
              docker rm "$container" || true
              echo "‚úÖ Container $container removido"
            else
              echo "‚úÖ Nenhum conflito detectado para: $container"
            fi
          done

          # ============================================================================
          # üßπ LIMPEZA DE STACK ANTERIOR (SE EXISTIR)
          # ============================================================================

          if docker stack ls --format "table {{.Name}}" | grep -q "^${STACK_NAME}$"; then
            echo "üóëÔ∏è Removendo stack anterior: $STACK_NAME"
            docker stack rm "$STACK_NAME"

            # Aguardar remo√ß√£o completa
            echo "‚è≥ Aguardando remo√ß√£o completa da stack..."
            timeout 120 bash -c "
              while docker stack ls --format 'table {{.Name}}' | grep -q '^${STACK_NAME}$'; do
                echo '  Aguardando remo√ß√£o da stack...'
                sleep 5
              done
            " || {
              echo "‚ö†Ô∏è Timeout na remo√ß√£o da stack - continuando..."
            }

            echo "‚úÖ Stack anterior removida"
          else
            echo "‚ÑπÔ∏è Nenhuma stack anterior encontrada: $STACK_NAME"
          fi

          echo "‚úÖ Limpeza inteligente conclu√≠da"

      - name: üöÄ Deploy Redis Stack
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-staging"

          echo "üöÄ Iniciando deploy do Redis Stack..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: docker-compose.yml"

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Deploy da stack
          echo "üîÑ Executando deploy da stack..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Stack deployada com sucesso"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos ficarem prontos..."
          timeout 180 bash -c "
            while true; do
              RUNNING=\$(docker stack services $STACK_NAME --format 'table {{.Replicas}}' | grep -v REPLICAS | grep -c '1/1' || echo '0')
              TOTAL=\$(docker stack services $STACK_NAME --format 'table {{.Name}}' | grep -v NAME | wc -l)
              
              echo \"  Servi√ßos prontos: \$RUNNING/\$TOTAL\"
              
              if [[ \$RUNNING -eq \$TOTAL && \$TOTAL -gt 0 ]]; then
                echo '‚úÖ Todos os servi√ßos est√£o prontos'
                break
              fi
              
              sleep 10
            done
          " || {
            echo "‚ö†Ô∏è Timeout aguardando servi√ßos - verificando status..."
            docker stack services "$STACK_NAME"
          }

          echo "üéâ Deploy do Redis conclu√≠do com sucesso!"

# ----------------------------------------------------------------------
# JOB 4 ‚ñ∏ DEPLOY PARA PRODU√á√ÉO
# ----------------------------------------------------------------------

  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üåü Deploy to Production
    timeout-minutes: 45
    needs: [deploy-staging]
    permissions:
      id-token: write
      contents: read
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      # ‚îÄ‚îÄ‚îÄ Valida√ß√£o inteligente de secrets OIDC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîê Validar e configurar secrets Azure OIDC Redis Produ√ß√£o
        shell: bash
        run: |
          echo "üîê Validando secrets OIDC para Redis Infrastructure Produ√ß√£o..."
          echo "üìÅ Reposit√≥rio: ${{ github.repository }}"

          # Verificar se secrets est√£o configurados neste reposit√≥rio espec√≠fico
          MISSING_SECRETS=""
          if [ -z "${{ secrets.AZURE_CLIENT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_CLIENT_ID"
          fi
          if [ -z "${{ secrets.AZURE_TENANT_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_TENANT_ID"
          fi
          if [ -z "${{ secrets.AZURE_SUBSCRIPTION_ID }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_SUBSCRIPTION_ID"
          fi
          if [ -z "${{ secrets.AZURE_KEYVAULT_ENDPOINT }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_KEYVAULT_ENDPOINT"
          fi
          if [ -z "${{ secrets.AZURE_KEYVAULT_NAME }}" ]; then
            MISSING_SECRETS="$MISSING_SECRETS AZURE_KEYVAULT_NAME"
          fi

          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Secrets ausentes no reposit√≥rio ${{ github.repository }}:$MISSING_SECRETS"
            echo ""
            echo "üîß SOLU√á√ÉO NECESS√ÅRIA:"
            echo "1. Acessar: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "2. Adicionar os seguintes Repository secrets:"
            echo "   - AZURE_CLIENT_ID: [Service Principal Client ID]"
            echo "   - AZURE_TENANT_ID: [Azure Tenant ID]"
            echo "   - AZURE_SUBSCRIPTION_ID: [Azure Subscription ID]"
            echo "   - AZURE_KEYVAULT_ENDPOINT: https://[vault-name].vault.azure.net"
            echo "   - AZURE_KEYVAULT_NAME: [vault-name]"
            echo ""
            echo "üí° Os values devem ser copiados do reposit√≥rio principal ou do Azure Portal"
            echo ""
            echo "‚ö†Ô∏è  PULANDO DEPLOY - Secrets de Redis Produ√ß√£o n√£o configurados"
            exit 0  # Exit com sucesso para n√£o falhar o pipeline, mas pular deploy
          fi

          echo "‚úÖ Secrets Redis Produ√ß√£o OIDC validados para ${{ github.repository }}"

      - name: üîë Azure Login (OIDC)
        uses: azure/login@v2
        timeout-minutes: 5
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: false

      # ‚îÄ‚îÄ‚îÄ Verifica√ß√£o p√≥s-login ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      - name: üîç Verificar conectividade Azure Redis Produ√ß√£o
        shell: bash
        run: |
          echo "üîç Verificando conectividade Azure Redis Produ√ß√£o..."

          if ACCOUNT_INFO=$(az account show --query "{name: name, id: id}" -o json 2>/dev/null); then
            echo "‚úÖ Login Azure Redis Produ√ß√£o confirmado:"
            echo "$ACCOUNT_INFO" | jq -r '"  Subscription: \(.name) (\(.id))"'
          else
            echo "‚ùå Falha login Azure Redis Produ√ß√£o"
            exit 1
          fi

      - name: üîê Sincronizar secrets do Azure Key Vault (Produ√ß√£o)
        shell: bash
        run: |
          echo "üîê Configurando sincroniza√ß√£o de secrets para produ√ß√£o..."

          # Extrair nome do vault do endpoint
          VAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          VAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME }}"

          echo "üîë Vault: $VAULT_NAME"
          echo "üåê Endpoint: $VAULT_ENDPOINT"

          # Tornar script execut√°vel
          chmod +x .github/workflows/scripts/sync-azure-keyvault-secrets.sh

          echo "üîê Sincronizando secrets do Azure Key Vault para produ√ß√£o..."

          # Executar sincroniza√ß√£o
          .github/workflows/scripts/sync-azure-keyvault-secrets.sh "$VAULT_NAME" "redis-infraestrutura"

          echo "‚úÖ Secrets de produ√ß√£o sincronizados com sucesso"

      - name: üöÄ Deploy Redis Production Stack
        run: |
          set -euo pipefail
          STACK_NAME="conexao-de-sorte-redis-production"

          echo "üöÄ Iniciando deploy do Redis Stack para PRODU√á√ÉO..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: docker-compose.yml"

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Deploy da stack
          echo "üîÑ Executando deploy da stack de produ√ß√£o..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Stack de produ√ß√£o deployada com sucesso"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos de produ√ß√£o ficarem prontos..."
          timeout 300 bash -c "
            while true; do
              RUNNING=\$(docker stack services $STACK_NAME --format 'table {{.Replicas}}' | grep -v REPLICAS | grep -c '1/1' || echo '0')
              TOTAL=\$(docker stack services $STACK_NAME --format 'table {{.Name}}' | grep -v NAME | wc -l)
              
              echo \"  Servi√ßos prontos: \$RUNNING/\$TOTAL\"
              
              if [[ \$RUNNING -eq \$TOTAL && \$TOTAL -gt 0 ]]; then
                echo '‚úÖ Todos os servi√ßos de produ√ß√£o est√£o prontos'
                break
              fi
              
              sleep 15
            done
          " || {
            echo "‚ö†Ô∏è Timeout aguardando servi√ßos de produ√ß√£o - verificando status..."
            docker stack services "$STACK_NAME"
          }

          echo "üéâ Deploy do Redis PRODU√á√ÉO conclu√≠do com sucesso!"

      - name: üîç Health Check Redis Production
        run: |
          echo "üîç Executando health check do Redis em produ√ß√£o..."
          
          # Aguardar um pouco mais para garantir que o Redis est√° completamente inicializado
          sleep 30
          
          # Tentar conectar ao Redis usando o service name do Docker Swarm
          REDIS_SERVICE="conexao-de-sorte-redis-production_redis"
          
          # Verificar se o servi√ßo est√° rodando
          if docker service ls | grep -q "$REDIS_SERVICE"; then
            echo "‚úÖ Servi√ßo Redis encontrado: $REDIS_SERVICE"
            
            # Tentar executar um ping no Redis
            if docker service logs "$REDIS_SERVICE" --tail 10 | grep -q "Ready to accept connections"; then
              echo "‚úÖ Redis est√° aceitando conex√µes"
            else
              echo "‚ö†Ô∏è Redis pode ainda estar inicializando - verificando logs..."
              docker service logs "$REDIS_SERVICE" --tail 20
            fi
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado"
            echo "Servi√ßos dispon√≠veis:"
            docker service ls
            exit 1
          fi
          
          echo "‚úÖ Health check do Redis conclu√≠do"

      - name: üìä Production Status Summary
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY DE PRODU√á√ÉO - REDIS INFRASTRUCTURE"
          echo "============================================================"
          echo "üïí Timestamp: $(date)"
          echo "üì¶ Stack: conexao-de-sorte-redis-production"
          echo "üîó Commit: ${{ github.sha }}"
          echo "üë§ Autor: ${{ github.actor }}"
          echo ""
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ STATUS: DEPLOY REALIZADO COM SUCESSO"
            echo ""
            echo "üî¥ Redis Infrastructure est√° rodando em produ√ß√£o"
            echo "üåê Dispon√≠vel na rede: conexao-network-swarm"
            echo "üîç Monitoramento: docker service logs conexao-de-sorte-redis-production_redis -f"
            echo ""
            echo "üìã Pr√≥ximos passos:"
            echo "  1. Verificar logs: docker service logs conexao-de-sorte-redis-production_redis"
            echo "  2. Monitorar performance"
            echo "  3. Validar conectividade com outros servi√ßos"
          else
            echo "‚ùå STATUS: FALHA NO DEPLOY"
            echo ""
            echo "üîß Para debug:"
            echo "  1. Verificar logs: docker service logs conexao-de-sorte-redis-production_redis"
            echo "  2. Verificar status: docker stack services conexao-de-sorte-redis-production"
            echo "  3. Verificar secrets: docker secret ls"
          fi