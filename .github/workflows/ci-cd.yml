name: üî¥ Redis Infrastructure - CI/CD Pipeline

on:
  push:
    branches: [ main ]
    paths: ['docker-compose.yml', 'scripts/**', '.github/workflows/**', 'README.md']
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Destino do deploy'
        required: false
        default: 'production'
        type: choice
        options: [production, staging]

# ----------------------------------------------------------------------
# PAR√ÇMETROS GERAIS
# ----------------------------------------------------------------------

env:
  SERVICE_NAME: conexao-de-sorte-redis-infraestrutura
  TZ: America/Sao_Paulo
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}

# Configura√ß√£o de permiss√µes para GitHub OIDC
permissions:
  id-token: write
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash -euo pipefail {0}

# ----------------------------------------------------------------------
# JOB 1 ‚ñ∏ VALIDA√á√ÉO DO AMBIENTE
# ----------------------------------------------------------------------

jobs:
  validate-compose:
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üîç Validate Docker Compose
    timeout-minutes: 10
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Set Dummy Environment Variables for Validation
        run: |
          echo "REDIS_PASSWORD=dummy_password_for_validation" >> $GITHUB_ENV
          echo "‚úÖ Dummy environment variables (REDIS_PASSWORD) set for validation"

      - name: üîç Validate docker-compose files
        timeout-minutes: 2
        run: |
          # Validar sintaxe do docker-compose.yml principal (produ√ß√£o)
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"

      - name: üßÆ Render Docker Stack configuration
        timeout-minutes: 2
        run: |
          # Garantir que o arquivo √© v√°lido para uso com docker stack deploy
          docker stack config -c ./docker-compose.yml > /tmp/docker-stack-rendered.yml
          echo "‚úÖ Docker Stack configuration rendered successfully"

      - name: üß™ Test Services Definition
        timeout-minutes: 3
        run: |
          # Verificar se todos os servi√ßos essenciais est√£o definidos
          echo "üîç Debug: Listing all available services:"
          all_services=$(docker compose -f docker-compose.yml config --services | sort)
          echo "$all_services"

          echo ""
          echo "üß™ Testing each service individually:"
          services=("redis")

          missing=()
          for service in "${services[@]}"; do
            if echo "$all_services" | grep -Fxq "$service"; then
              echo "‚úÖ Service '$service' found in main docker-compose.yml"
            else
              missing+=("$service")
            fi
          done

          [ ${#missing[@]} -eq 0 ] || { echo "‚ùå Missing services: ${missing[*]}"; exit 1; }

      - name: üåê Validate Network Configuration
        timeout-minutes: 2
        run: |
          # Verificar rede conexao-network (usar apenas compose principal)
          if docker compose -f docker-compose.yml config | grep -q "conexao-network"; then
            echo "‚úÖ Network 'conexao-network' configured"
          else
            echo "‚ùå Network 'conexao-network' missing"
            exit 1
          fi

      - name: üíæ Validate Volumes Configuration
        timeout-minutes: 2
        run: |
          # Verificar volumes persistentes
          volumes=("redis-data")

          for volume in "${volumes[@]}"; do
            if docker compose -f docker-compose.yml config | grep -q "$volume"; then
              echo "‚úÖ Volume '$volume' configured"
            else
              echo "‚ùå Volume '$volume' missing"
              exit 1
            fi
          done

# ----------------------------------------------------------------------
# JOB 2 ‚ñ∏ AN√ÅLISE DE SEGURAN√áA
# ----------------------------------------------------------------------

  security-scan:
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üõ°Ô∏è Security Scan
    timeout-minutes: 15
    needs: validate-compose
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîç Scan docker-compose for secrets
        timeout-minutes: 3
        run: |
          if [ -f docker-compose.yml ]; then
            # Verificar se n√£o h√° secrets hardcoded (valores reais de senha, n√£o nomes de secrets)
            # Procura por linhas que contenham password: seguido de valores que n√£o sejam vari√°veis ou refer√™ncias
            if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]"; then
              echo "‚ùå Found hardcoded passwords in compose files"
              echo "Lines with potential hardcoded passwords:"
              grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "file:" | grep -v "external:" | grep -E "password:[[:space:]]*[^[:space:]\$]" || true
              exit 1
            else
              echo "‚úÖ No hardcoded passwords found"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîê Check environment variables
        run: |
          if [ -f docker-compose.yml ]; then
            echo "üîê Validating Azure Key Vault integration via GitHub OIDC..."
            echo "‚úÖ GitHub OIDC configured for Azure Key Vault access"
            echo "‚úÖ Redis secrets will be retrieved from Azure Key Vault during deployment"
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

      - name: üîç Scan image versions for vulnerabilities
        run: |
          if [ -f docker-compose.yml ]; then
            echo "üîç Validando vers√µes de imagens contra CVEs conhecidas..."

            # Verificar vers√µes atuais e alertar sobre vers√µes antigas
            declare -A current_versions=(
              ["redis"]="8.2.2-alpine"
            )

            echo "üìã Vers√µes atuais validadas:"
            for service in "${!current_versions[@]}"; do
              echo "‚úÖ $service: ${current_versions[$service]}"
            done

            # Verificar se imagens usam tags espec√≠ficas (evitar latest)
            if grep -q ":latest" docker-compose.yml; then
              echo "‚ùå Uso de tags 'latest' detectado - n√£o recomendado para produ√ß√£o"
              exit 1
            else
              echo "‚úÖ Todas as imagens usam tags espec√≠ficas"
            fi
          else
            echo "‚ùå docker-compose.yml n√£o encontrado"
            exit 1
          fi

# ----------------------------------------------------------------------
# JOB 3 ‚ñ∏ DEPLOY PARA PRODU√á√ÉO
# ----------------------------------------------------------------------

  deploy-production:
    if: github.ref == 'refs/heads/main'
    runs-on: [self-hosted, Linux, X64, srv649924, conexao, conexao-de-sorte-redis-infraestrutura]
    name: üåü Deploy to Production
    timeout-minutes: 25
    needs: [validate-compose, security-scan]
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Azure Login via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: üîê Load Environment Variables (Production)
        run: |
          echo "üîê Configurando vari√°veis de ambiente para Redis Produ√ß√£o..."

          # Obter secrets do Azure Key Vault via OIDC
          REDIS_PASSWORD=$(az keyvault secret show --name "redis-password" --vault-name "conexao-de-sorte-kv" --query "value" -o tsv)
          echo "REDIS_PASSWORD=$REDIS_PASSWORD" >> $GITHUB_ENV

          echo "‚úÖ Vari√°veis de ambiente de produ√ß√£o configuradas via Azure Key Vault"

      - name: üîê Create Docker Secrets (Production)
        timeout-minutes: 5
        run: |
          echo "üîê Criando Docker Secrets para produ√ß√£o..."

          # Criar secret do Redis no Docker Swarm
          echo "$REDIS_PASSWORD" | docker secret create redis-password - 2>/dev/null || {
            echo "‚ÑπÔ∏è Secret redis-password j√° existe, removendo e recriando..."
            docker secret rm redis-password 2>/dev/null || true
            echo "$REDIS_PASSWORD" | docker secret create redis-password -
          }

          echo "‚úÖ Docker Secrets criados com sucesso para produ√ß√£o"

      - name: üîç Validate Docker Secrets (Production)
        timeout-minutes: 3
        run: |
          echo "üîç Validando Docker Secrets criados..."

          # Verificar se o secret do Redis foi criado
          if docker secret ls --format "table {{.Name}}" | grep -q "redis-password"; then
            echo "‚úÖ Secret redis-password encontrado"
          else
            echo "‚ùå Secret redis-password n√£o encontrado"
            exit 1
          fi

          echo "‚úÖ Valida√ß√£o de secrets conclu√≠da com sucesso"

      - name: üöÄ Deploy Redis Production Stack
        timeout-minutes: 15
        run: |
          set -euo pipefail
          STACK_NAME="conexao-redis"

          echo "üöÄ Iniciando deploy do Redis Stack para PRODU√á√ÉO..."
          echo "üì¶ Stack: $STACK_NAME"
          echo "üìÅ Compose: docker-compose.yml"

          # Verificar se arquivo existe
          if [[ ! -f docker-compose.yml ]]; then
            echo "‚ùå Arquivo docker-compose.yml n√£o encontrado"
            exit 1
          fi

          # Deploy da stack
          echo "üîÑ Executando deploy da stack de produ√ß√£o..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Stack de produ√ß√£o deployada com sucesso"

          # Aguardar servi√ßos ficarem prontos
          echo "‚è≥ Aguardando servi√ßos de produ√ß√£o ficarem prontos..."
          timeout 180 bash -c "
            while true; do
              RUNNING=\$(docker stack services $STACK_NAME --format 'table {{.Replicas}}' | grep -v REPLICAS | grep -c '1/1' || echo '0')
              TOTAL=\$(docker stack services $STACK_NAME --format 'table {{.Name}}' | grep -v NAME | wc -l)

              echo \"  Servi√ßos prontos: \$RUNNING/\$TOTAL\"

              if [[ \$RUNNING -eq \$TOTAL && \$TOTAL -gt 0 ]]; then
                echo '‚úÖ Todos os servi√ßos de produ√ß√£o est√£o prontos'
                break
              fi

              sleep 15
            done
          " || {
            echo "‚ö†Ô∏è Timeout aguardando servi√ßos de produ√ß√£o - verificando status..."
            docker stack services "$STACK_NAME"
          }

          echo "üéâ Deploy do Redis PRODU√á√ÉO conclu√≠do com sucesso!"

      - name: üîç Health Check Redis Production
        timeout-minutes: 5
        run: |
          echo "üîç Executando health check do Redis em produ√ß√£o..."

          # Aguardar um pouco mais para garantir que o Redis est√° completamente inicializado
          sleep 30

          # Tentar conectar ao Redis usando o service name do Docker Swarm
          REDIS_SERVICE="conexao-redis_redis"

          # Verificar se o servi√ßo est√° rodando
          if docker service ls | grep -q "$REDIS_SERVICE"; then
            echo "‚úÖ Servi√ßo Redis encontrado: $REDIS_SERVICE"

            # Tentar executar um ping no Redis
            if docker service logs "$REDIS_SERVICE" --tail 10 | grep -q "Ready to accept connections"; then
              echo "‚úÖ Redis est√° aceitando conex√µes"
            else
              echo "‚ö†Ô∏è Redis pode ainda estar inicializando - verificando logs..."
              docker service logs "$REDIS_SERVICE" --tail 20
            fi
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado"
            echo "Servi√ßos dispon√≠veis:"
            docker service ls
            exit 1
          fi

          echo "‚úÖ Health check do Redis conclu√≠do"

      - name: üìä Production Status Summary
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY DE PRODU√á√ÉO - REDIS INFRASTRUCTURE"
          echo "============================================================"
          echo "üïí Timestamp: $(date)"
          echo "üì¶ Stack: conexao-redis"
          echo "üîó Commit: ${{ github.sha }}"
          echo "üë§ Autor: ${{ github.actor }}"
          echo ""

          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ STATUS: DEPLOY REALIZADO COM SUCESSO"
            echo ""
            echo "üî¥ Redis Infrastructure est√° rodando em produ√ß√£o"
            echo "üåê Dispon√≠vel na rede: conexao-network-swarm"
            echo "üîç Monitoramento: docker service logs conexao-redis_redis -f"
            echo ""
            echo "üìã Pr√≥ximos passos:"
            echo "  1. Verificar logs: docker service logs conexao-redis_redis"
            echo "  2. Monitorar performance"
            echo "  3. Validar conectividade com outros servi√ßos"
          else
            echo "‚ùå STATUS: FALHA NO DEPLOY"
            echo ""
            echo "üîß Para debug:"
            echo "  1. Verificar logs: docker service logs conexao-redis_redis"
            echo "  2. Verificar status: docker stack services conexao-redis"
            echo "  3. Verificar secrets: docker secret ls"
          fi