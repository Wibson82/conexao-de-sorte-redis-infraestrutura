name: "üî¥ Redis Infrastructure ‚Äì CI/CD Pipeline"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  SERVICE_NAME: redis-infrastructure
  STACK_NAME: conexao-redis
  DOCKER_NETWORK_NAME: conexao-network-swarm

permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq
      - name: üîç Validar identificadores Azure (vars)
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID || secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID || secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID || secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_ENDPOINT: ${{ vars.AZURE_KEYVAULT_ENDPOINT || secrets.AZURE_KEYVAULT_ENDPOINT }}
          AZURE_KEYVAULT_NAME: ${{ vars.AZURE_KEYVAULT_NAME || secrets.AZURE_KEYVAULT_NAME }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf '‚ùå GitHub Secrets obrigat√≥rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "‚úÖ Identificadores Azure configurados via vars (fallback para secrets)"
          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

          # Key Vault opcional para Redis - verificar ENDPOINT primeiro, depois NAME (migra√ß√£o segura)
          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo "‚úÖ AZURE_KEYVAULT_ENDPOINT configurado via vars"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            # Extrair nome do endpoint para compatibilidade
            KEYVAULT_NAME=$(echo "$AZURE_KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "keyvault_name=$KEYVAULT_NAME" >> "$GITHUB_OUTPUT"
          elif [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "‚úÖ AZURE_KEYVAULT_NAME configurado via vars (fallback)"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
            echo "keyvault_name=$AZURE_KEYVAULT_NAME" >> "$GITHUB_OUTPUT"
          else
            echo "‚ÑπÔ∏è Nenhum Key Vault configurado - Redis n√£o requer segredos complexos"
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Validate Docker Compose
        run: |
          # Validar sintaxe do docker-compose.yml
          docker compose -f docker-compose.yml config -q
          echo "‚úÖ Docker Compose syntax is valid"
      - name: Security Validation - No Hardcoded Passwords
        run: |
          # Verificar se n√£o h√° hardcoded passwords (excluindo secret names)
          if grep -r "password.*:" docker-compose.yml | grep -v "\${" | grep -v "#" | grep -v "external:" | grep -v "secrets:" | grep -v "conexao-de-sorte-.*-password:"; then
            echo "‚ùå Found potential hardcoded passwords"
            exit 1
          else
            echo "‚úÖ No hardcoded passwords found"
          fi
          # Verificar fail-safe pattern
          if grep -q "FATAL.*refusing to start" docker-compose.yml; then
            echo "‚úÖ Fail-safe security pattern implemented"
          else
            echo "‚ö†Ô∏è Fail-safe pattern recommended but not critical"
          fi
          # Verificar exposi√ß√£o Redis (seguindo padr√£o RabbitMQ que funcionou)
          if grep -E "^\s*ports:" docker-compose.yml; then
            echo "‚ö†Ô∏è WARNING: Redis may have exposed ports - ensure firewall protection"
            echo "üìù Note: Following RabbitMQ success pattern (commit 66154f5)"
          else
            echo "‚úÖ No ports exposed - maximum security (overlay network only)"
          fi

      - name: Validate YAML files
        run: |
          python3 -c "
          import yaml
          import pathlib

          # Validar arquivos YAML principais
          yaml_files = [
              'docker-compose.yml'
          ]

          for file_path in yaml_files:
              if pathlib.Path(file_path).exists():
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          yaml.safe_load(f)
                      print(f'‚úÖ YAML v√°lido: {file_path}')
                  except Exception as e:
                      print(f'‚ùå Erro no YAML {file_path}: {e}')
                      exit(1)
          "

      - name: ‚úÖ Confirmar consumo m√≠nimo do Key Vault
        if: ${{ steps.check_secrets.outputs.has_keyvault == 'true' }}
        run: |
          echo 'Job de valida√ß√£o n√£o consome segredos do Key Vault (lista vazia).'
          echo "‚úÖ Valida√ß√£o de Key Vault conclu√≠da sem consumo de segredos"

      - name: Validation completed
        run: |
          echo "‚úÖ Valida√ß√£o conclu√≠da - pronto para deploy"
  deploy-selfhosted:
    needs: validate-and-build
    runs-on: [ self-hosted, Linux, X64, conexao-de-sorte-redis-infraestrutura ]
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: üîç Diagn√≥sticos iniciais
        run: |
          echo "üîç Verificando arquivos necess√°rios..."
          for required_file in "docker-compose.yml"; do
            if [[ -f "$required_file" ]]; then
              echo "‚úÖ $required_file encontrado"
            else
              echo "‚ùå $required_file N√ÉO encontrado"
              exit 1
            fi
          done
          echo "üìÇ Validando diret√≥rios cr√≠ticos..."
          required_dirs=()
          if (( ${#required_dirs[@]} )); then
            for required_dir in "${required_dirs[@]}"; do
              if [[ -d "$required_dir" ]]; then
                echo "‚úÖ Diret√≥rio $required_dir existe"
              else
                echo "‚ö†Ô∏è Diret√≥rio $required_dir n√£o existe - criando..."
                mkdir -p "$required_dir"
              fi
            done
          else
            echo "‚ÑπÔ∏è Nenhum diret√≥rio local obrigat√≥rio para Redis"
          fi
      - name: üîê Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get Key Vault secrets (Redis)
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          # Usar endpoint se dispon√≠vel, sen√£o usar nome com fallback
          KEYVAULT_ENDPOINT="${{ secrets.AZURE_KEYVAULT_ENDPOINT }}"
          if [[ -n "$KEYVAULT_ENDPOINT" ]]; then
            KEYVAULT_NAME=$(echo "$KEYVAULT_ENDPOINT" | sed 's|https://\(.*\)\.vault\.azure\.net/.*|\1|')
            echo "üìç Usando Key Vault do endpoint: $KEYVAULT_NAME"
          else
            KEYVAULT_NAME="${{ secrets.AZURE_KEYVAULT_NAME || 'kv-conexao-de-sorte' }}"
            echo "üìç Usando Key Vault do nome: $KEYVAULT_NAME"
          fi

          # Obter secrets do Redis
          secrets_list="conexao-de-sorte-redis-password"

          IFS=',' read -ra SECRETS_ARRAY <<< "$secrets_list"
          for secret_name in "${SECRETS_ARRAY[@]}"; do
            echo "üîç Obtendo segredo: $secret_name"
            secret_value=$(az keyvault secret show --vault-name "$KEYVAULT_NAME" --name "$secret_name" --query 'value' -o tsv 2>/dev/null || echo "")

            if [[ -n "$secret_value" ]]; then
              echo "‚úÖ Segredo obtido: $secret_name"
              echo "$secret_name=$secret_value" >> $GITHUB_ENV
            else
              echo "‚ùå Erro ao obter segredo: $secret_name"
              exit 1
            fi
          done

      - name: Preparar secrets do Redis
        if: ${{ needs.validate-and-build.outputs.has_keyvault == 'true' }}
        run: |
          set -Eeuo pipefail
          password="${conexao-de-sorte-redis-password}"
          if [[ -z "$password" ]]; then
            echo '‚ùå Segredo do Redis n√£o retornado pelo Key Vault'
            exit 1
          fi
          echo "::add-mask::$password"
          if [[ ${#password} -lt 12 ]]; then
            echo '‚ùå Password muito curto (m√≠nimo 12 caracteres)'
            exit 1
          fi
          password_file="$RUNNER_TEMP/redis_password"
          printf '%s\n' "$password" > "$password_file"
          chmod 600 "$password_file"
      - name: Deploy Redis Infrastructure
        run: |
          set -Eeuo pipefail
          echo "üöÄ Iniciando deploy da infraestrutura Redis..."

          STACK_NAME="conexao-redis"
          NETWORK_NAME="conexao-network-swarm"
          SECRET_NAME="conexao-de-sorte-redis-password"

          # Verificar se rede existe
          if ! docker network ls --format '{{.Name}}' | grep -Fxq "$NETWORK_NAME"; then
            echo "üì° Criando rede overlay $NETWORK_NAME..."
            docker network create --driver overlay --attachable "$NETWORK_NAME"
          else
            echo "‚úÖ Rede $NETWORK_NAME j√° existe"
          fi

          # Verificar e criar volume se necess√°rio
          if ! docker volume ls --format '{{.Name}}' | grep -Fxq "redis_data"; then
            echo "üíæ Criando volume redis_data..."
            docker volume create redis_data
          else
            echo "‚úÖ Volume redis_data j√° existe"
          fi

          # Gerenciar secret
          if [[ "${{ needs.validate-and-build.outputs.has_keyvault }}" == "true" ]]; then
            password_file="$RUNNER_TEMP/redis_password"

            # Verificar se secret existe
            if docker secret ls --format '{{.Name}}' | grep -Fxq "$SECRET_NAME"; then
              echo "‚ÑπÔ∏è Secret $SECRET_NAME j√° existe - utilizando existente"
            else
              echo "üîë Criando secret $SECRET_NAME..."
              docker secret create "$SECRET_NAME" "$password_file"
            fi
          else
            echo "‚ö†Ô∏è Key Vault n√£o configurado - usando secret existente"
            if ! docker secret ls --format '{{.Name}}' | grep -Fxq "$SECRET_NAME"; then
              echo "‚ùå Secret $SECRET_NAME n√£o encontrado e Key Vault n√£o configurado"
              exit 1
            fi
          fi

          # Remove stack existente se houver
          if docker stack ls --format '{{.Name}}' | grep -Fxq "$STACK_NAME"; then
            echo "üîÑ Removendo stack existente $STACK_NAME..."
            docker stack rm "$STACK_NAME"

            # Aguardar remo√ß√£o
            echo "‚è≥ Aguardando remo√ß√£o da stack..."
            for i in $(seq 1 30); do
              if ! docker stack ls --format '{{.Name}}' | grep -Fxq "$STACK_NAME"; then
                break
              fi
              sleep 2
            done
          fi

          # Deploy da nova stack
          echo "üõ†Ô∏è Fazendo deploy da stack $STACK_NAME..."
          docker stack deploy -c docker-compose.yml "$STACK_NAME"

          echo "‚úÖ Deploy conclu√≠do!"
      - name: Health Check Redis (Non-blocking)
        run: |
          echo "üè• Verificando sa√∫de do Redis..."
          STACK_NAME="conexao-redis"

          # Aguardar servi√ßos ficarem dispon√≠veis (m√°ximo 2 minutos)
          timeout=120
          elapsed=0

          while [ $elapsed -lt $timeout ]; do
            # Verificar status dos servi√ßos
            service_count=$(docker service ls --filter name="${STACK_NAME}_" --format '{{.Name}}' | wc -l)

            if [ $service_count -gt 0 ]; then
              echo "‚úÖ Servi√ßos Redis encontrados"
              docker service ls --filter name="${STACK_NAME}_" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

              # Verificar se h√° containers rodando
              running_tasks=$(docker service ps "${STACK_NAME}_redis" --filter desired-state=running --format '{{.Name}}' 2>/dev/null | wc -l)

              if [ $running_tasks -gt 0 ]; then
                echo "‚úÖ Redis est√° sendo executado"
                break
              fi
            fi

            echo "‚è≥ Aguardando Redis ficar dispon√≠vel... ($elapsed/$timeout segundos)"
            sleep 10
            elapsed=$((elapsed + 10))
          done

          # Status final (n√£o bloqueante)
          echo "üìä Status final dos servi√ßos Redis:"
          docker service ls --filter name="${STACK_NAME}_" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}" || true

          echo "üìã Tarefas do Redis:"
          docker service ps "${STACK_NAME}_redis" --no-trunc --format "table {{.Name}}\t{{.CurrentState}}\t{{.Error}}" || true

          echo "‚ÑπÔ∏è Health check conclu√≠do (informativo apenas - n√£o bloqueia pipeline)"
      - name: Connectivity Validation
        run: |
          echo "üåê Validando conectividade do Redis..."
          # Verificar se o servi√ßo est√° listado no Swarm
          if docker service ls | grep -q "${STACK_NAME}_redis"; then
            echo "‚úÖ Servi√ßo Redis encontrado no Swarm"
          else
            echo "‚ùå Servi√ßo Redis n√£o encontrado no Swarm"
            exit 1
          fi
          # Verificar se est√° na rede correta
          if docker network inspect "$DOCKER_NETWORK_NAME" | grep -q redis; then
            echo "‚úÖ Redis conectado √† rede overlay"
          else
            echo "‚ö†Ô∏è Redis pode n√£o estar na rede overlay correta"
          fi
          # Verificar endpoints espec√≠ficos
          REDIS_CONTAINER=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)
          if [ -n "$REDIS_CONTAINER" ]; then
            # Testar Redis port
            if docker exec "$REDIS_CONTAINER" ss -tuln 2>/dev/null | grep -q ":6379"; then
              echo "‚úÖ Redis port ativo (porta 6379)"
            else
              echo "‚ÑπÔ∏è Redis port n√£o detectado"
            fi
          fi
          echo "üìä Status final dos servi√ßos:"
          docker service ls --filter name="${STACK_NAME}_*" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"
          echo "üîç Status detalhado do servi√ßo Redis:"
          docker service ps "${STACK_NAME}_redis" --no-trunc || true