name: "ğŸ”´ Redis Infrastructure Deploy - Fixed"

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  SERVICE_NAME: redis-infrastructure
  STACK_NAME: conexao-redis
  DOCKER_NETWORK_NAME: conexao-network-swarm
  REDIS_DATA_VOLUME: redis_data
  REDIS_SECRET_NAME: conexao-de-sorte-redis-password
  REDIS_KV_SECRET_NAME: conexao-de-sorte-redis-password

jobs:
  validate-and-build:
    runs-on: ubuntu-latest
    timeout-minutes: 12
    permissions:
      contents: read
      id-token: write
      packages: read
    outputs:
      has_keyvault: ${{ steps.check_secrets.outputs.has_keyvault }}
      has_azure_creds: ${{ steps.check_secrets.outputs.has_azure_creds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          fetch-depth: 1

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-yaml jq

      - name: ğŸ” Validar identificadores Azure (vars)
        id: check_secrets
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_KEYVAULT_NAME: ${{ secrets.AZURE_KEYVAULT_NAME }}
          AZURE_KEYVAULT_ENDPOINT: ${{ secrets.AZURE_KEYVAULT_ENDPOINT }}
        run: |
          set -Eeuo pipefail
          missing=()
          for var in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            if [[ -z "${!var:-}" ]]; then
              missing+=("$var")
            fi
          done
          if (( ${#missing[@]} )); then
            printf 'âŒ GitHub Secrets obrigatÃ³rios ausentes: %s\n' "${missing[*]}"
            exit 1
          fi
          echo "::add-mask::${AZURE_CLIENT_ID}"
          echo "::add-mask::${AZURE_TENANT_ID}"
          echo "::add-mask::${AZURE_SUBSCRIPTION_ID}"
          echo "has_azure_creds=true" >> "$GITHUB_OUTPUT"

          if [[ -n "${AZURE_KEYVAULT_NAME:-}" ]]; then
            echo "::add-mask::${AZURE_KEYVAULT_NAME}"
            echo "has_keyvault=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_keyvault=false" >> "$GITHUB_OUTPUT"
            echo 'â„¹ï¸ Key Vault nÃ£o configurado (Redis usarÃ¡ secret existente no Swarm)'
          fi

          if [[ -n "${AZURE_KEYVAULT_ENDPOINT:-}" ]]; then
            echo "::add-mask::${AZURE_KEYVAULT_ENDPOINT}"
          fi

      - name: Validate docker-compose.yml
        run: |
          set -Eeuo pipefail
          docker compose -f docker-compose.yml config -q
          echo "âœ… docker-compose.yml syntax ok"

      - name: Security validation
        run: |
          set -Eeuo pipefail
          if grep -R "password[[:space:]]*:" docker-compose.yml | grep -v '\${' | grep -v '^#' | grep -v 'external:'; then
            echo "âŒ Possible hardcoded password detected"
            exit 1
          fi
          echo "âœ… No hardcoded passwords detected"

          if grep -Eq "^\s*-\s*'?6379:'?" docker-compose.yml; then
            echo "âš ï¸ Port 6379 appears exposed; confirme necessidade de acesso direto" >&2
          else
            echo "âœ… Port 6379 not exposed"
          fi

      - name: Validate Redis Configuration
        run: |
          set -Eeuo pipefail
          echo "ğŸ” Validando configuraÃ§Ãµes Redis..."

          # Verificar se estÃ¡ usando Redis 8.x
          if grep -q "redis:8" docker-compose.yml; then
            echo "âœ… Redis 8.x detectado"
          else
            echo "âŒ Redis versÃ£o nÃ£o Ã© 8.x"
            exit 1
          fi

          # Verificar configuraÃ§Ãµes de seguranÃ§a
          if grep -q "requirepass" redis.conf; then
            echo "âœ… ConfiguraÃ§Ã£o requirepass encontrada"
          else
            echo "âŒ ConfiguraÃ§Ã£o requirepass ausente"
            exit 1
          fi

          # Verificar comandos perigosos desabilitados
          if grep -q "rename-command FLUSHALL" redis.conf; then
            echo "âœ… Comandos perigosos desabilitados"
          else
            echo "âš ï¸ Comandos perigosos podem estar habilitados"
          fi

          echo "âœ… ConfiguraÃ§Ã£o Redis validada"

  deploy-selfhosted:
    needs: [validate-and-build]
    runs-on: [self-hosted, Linux, X64, conexao-de-sorte-redis-infraestrutura]
    timeout-minutes: 25
    if: github.ref == 'refs/heads/main' && always()
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4.3.0
        with:
          clean: true
          fetch-depth: 1

      - name: ğŸ” DiagnÃ³sticos iniciais
        run: |
          set -Eeuo pipefail
          echo "ğŸ” Verificando arquivos necessÃ¡rios..."
          for required_file in "docker-compose.yml" "redis.conf"; do
            if [[ -f "$required_file" ]]; then
              echo "âœ… $required_file encontrado"
            else
              echo "âŒ $required_file NÃƒO encontrado"
              exit 1
            fi
          done

          echo "ğŸ” Verificando Docker Swarm..."
          if ! docker info | grep -q "Swarm: active"; then
            echo "âŒ Docker Swarm nÃ£o estÃ¡ ativo"
            exit 1
          fi
          echo "âœ… Docker Swarm ativo"

      - name: ğŸ§¹ Cleanup Local Redis Resources
        run: |
          set -Eeuo pipefail
          echo "ğŸ§¹ Limpando recursos Redis locais..."

          echo "ğŸ” ServiÃ§os Redis atuais:"
          docker service ls --filter name=redis || true

          # Remover serviÃ§os Redis existentes
          redis_services=$(docker service ls --filter name=redis --format "{{.Name}}" 2>/dev/null || true)
          if [[ -n "$redis_services" ]]; then
            echo "ğŸ—‘ï¸ Removendo serviÃ§os Redis existentes..."
            echo "$redis_services" | while read -r service; do
              if [[ -n "$service" ]]; then
                echo "ğŸ”„ Removendo serviÃ§o: $service"
                docker service rm "$service" || echo "âš ï¸ Falha ao remover $service"
              fi
            done
            echo "â° Aguardando remoÃ§Ã£o completa dos serviÃ§os..."
            sleep 30
          else
            echo "âœ… Nenhum serviÃ§o Redis para remover"
          fi

          echo "âœ… Limpeza local concluÃ­da"

      - name: ğŸ” Azure Login (OIDC)
        if: ${{ needs.validate-and-build.outputs.has_azure_creds == 'true' }}
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: ğŸ” Get secrets from Azure Key Vault
        uses: azure/get-keyvault-secrets@v1
        with:
          keyvault: "kv-conexao-de-sorte"
          secrets: |
            conexao-de-sorte-redis-password
        id: kv

      - name: ğŸ”’ Mask sensitive values
        run: |
          echo ::add-mask::"${{ steps.kv.outputs.conexao-de-sorte-redis-password }}"

      - name: ğŸš€ Deploy Redis Stack
        env:
          STACK_NAME: ${{ env.STACK_NAME }}
          DOCKER_NETWORK_NAME: ${{ env.DOCKER_NETWORK_NAME }}
          REDIS_DATA_VOLUME: ${{ env.REDIS_DATA_VOLUME }}
          REDIS_SECRET_NAME: ${{ env.REDIS_SECRET_NAME }}
          HAS_KEYVAULT: ${{ needs.validate-and-build.outputs.has_keyvault }}
          REDIS_PASSWORD: ${{ steps.kv.outputs.conexao-de-sorte-redis-password }}
        run: |
          set -Eeuo pipefail
          compose_file="docker-compose.yml"
          secret_name="$REDIS_SECRET_NAME"
          has_keyvault="${HAS_KEYVAULT:-false}"
          password="${REDIS_PASSWORD:-}"

          echo "ğŸ” Verificando recursos necessÃ¡rios..."

          # Criar rede se nÃ£o existir
          if ! docker network ls --format '{{.Name}}' | grep -Fxq "$DOCKER_NETWORK_NAME"; then
            echo "âš ï¸ Criando rede '$DOCKER_NETWORK_NAME'..."
            docker network create --driver overlay --attachable "$DOCKER_NETWORK_NAME"
            echo "âœ… Rede '$DOCKER_NETWORK_NAME' criada"
          else
            echo "âœ… Rede '$DOCKER_NETWORK_NAME' jÃ¡ existe"
          fi

          # Criar volume se nÃ£o existir
          if ! docker volume ls --format '{{.Name}}' | grep -Fxq "$REDIS_DATA_VOLUME"; then
            echo "âš ï¸ Criando volume '$REDIS_DATA_VOLUME'..."
            docker volume create --name "$REDIS_DATA_VOLUME"
            echo "âœ… Volume '$REDIS_DATA_VOLUME' criado"
          else
            echo "âœ… Volume '$REDIS_DATA_VOLUME' jÃ¡ existe"
          fi

          # Gerenciar secret
          if [[ "$has_keyvault" == "true" ]]; then
            if [[ -z "$password" ]]; then
              echo "âŒ Senha do Redis nÃ£o foi obtida do Key Vault"
              exit 1
            fi

            tmp_file=$(mktemp)
            cleanup() { rm -f "$tmp_file"; }
            trap cleanup EXIT
            printf '%s' "$password" > "$tmp_file"

            if docker secret ls --format '{{.Name}}' | grep -Fxq "$secret_name"; then
              echo "â„¹ï¸ Secret '$secret_name' jÃ¡ existe - utilizando existente"
            else
              echo "ğŸ”„ Criando secret '$secret_name'..."
              docker secret create "$secret_name" "$tmp_file"
              echo "âœ… Secret '$secret_name' criado"
            fi
          else
            if ! docker secret ls --format '{{.Name}}' | grep -Fxq "$secret_name"; then
              echo "âŒ Secret '$secret_name' nÃ£o encontrado e Key Vault desabilitado"
              exit 1
            fi
            echo "âœ… Utilizando secret existente '$secret_name'"
          fi

          # Deploy da stack
          if docker stack ls --format '{{.Name}}' | grep -Fxq "$STACK_NAME"; then
            echo "ğŸ”„ Atualizando stack '$STACK_NAME'..."
            docker stack deploy -c "$compose_file" "$STACK_NAME"
            echo "â° Aguardando atualizaÃ§Ã£o..."
            sleep 30
          else
            echo "ğŸ› ï¸ Criando stack '$STACK_NAME'..."
            docker stack deploy -c "$compose_file" "$STACK_NAME"
            echo "â° Aguardando inicializaÃ§Ã£o..."
            sleep 45
          fi

      - name: ğŸ¥ Redis Health Check
        run: |
          set -Eeuo pipefail
          timeout=300
          elapsed=0
          health_passed=false

          echo "ğŸ¥ Iniciando health check do Redis (timeout: $timeout segundos)..."

          while [ $elapsed -lt $timeout ] && [ "$health_passed" = false ]; do
            redis_container=$(docker ps -q -f name="${STACK_NAME}_redis" | head -1)

            if [ -n "$redis_container" ]; then
              echo "ğŸ” Testando Redis ($elapsed/$timeout segundos)..."

              # Teste redis-cli ping
              if docker exec "$redis_container" redis-cli --no-auth-warning -a "$(cat /run/secrets/conexao-de-sorte-redis-password)" ping 2>/dev/null | grep -q "PONG"; then
                echo "âœ… Redis respondeu ao ping"
                health_passed=true
                break
              fi

              # Teste porta 6379
              if docker exec "$redis_container" ss -tuln 2>/dev/null | grep -q ':6379'; then
                echo "âœ… Porta 6379 ativa"
                health_passed=true
                break
              fi

              echo "â³ Redis inicializando..."
            else
              if [ $((elapsed % 30)) -eq 0 ]; then
                echo "â„¹ï¸ Status do serviÃ§o:"
                docker service ps "${STACK_NAME}_redis" --no-trunc || true
              fi
              echo "â³ Container ainda nÃ£o encontrado..."
            fi

            sleep 10
            elapsed=$((elapsed + 10))
          done

          if [ "$health_passed" = false ]; then
            echo "âŒ Redis health check FALHOU apÃ³s $timeout segundos"

            if [ -n "$redis_container" ]; then
              echo "ğŸ“‹ Logs do Redis:"
              docker logs "$redis_container" --tail 50 2>&1 || true
            fi

            echo "ğŸ“‹ Status do serviÃ§o:"
            docker service ps "${STACK_NAME}_redis" --no-trunc || true
            exit 1
          fi

          echo "ğŸ’š Redis estÃ¡ saudÃ¡vel e pronto!"

      - name: âœ… Final Validation
        run: |
          set -Eeuo pipefail
          echo "ğŸ“Š Status final dos serviÃ§os:"
          docker service ls --filter name="${STACK_NAME}" --format "table {{.Name}}\t{{.Replicas}}\t{{.Image}}"

          echo "ğŸ” Secrets disponÃ­veis:"
          docker secret ls --filter name="${REDIS_SECRET_NAME}" --format "table {{.Name}}\t{{.CreatedAt}}"

          echo "ğŸ’¾ Volume criado:"
          if docker volume ls --format '{{.Name}}' | grep -Fxq "$REDIS_DATA_VOLUME"; then
            echo "âœ… Volume '$REDIS_DATA_VOLUME'"
          fi

          echo "ğŸ›¡ï¸ VerificaÃ§Ãµes de seguranÃ§a:"
          # Verificar se porta nÃ£o estÃ¡ exposta
          if docker service inspect "${STACK_NAME}_redis" --format '{{range .Spec.TaskTemplate.ContainerSpec.Ports}}{{.PublishedPort}}{{end}}' 2>/dev/null | grep -q "6379"; then
            echo "âŒ CRÃTICO: Porta 6379 exposta externamente!"
            exit 1
          else
            echo "âœ… Porta 6379 segura (somente rede interna)"
          fi

      - name: ğŸ“Š Deployment Summary
        run: |
          echo "========================================"
          echo "ğŸ”´ REDIS DEPLOYMENT SUMMARY"
          echo "========================================"
          echo ""
          echo "ğŸ› ï¸ Stack: $STACK_NAME"
          echo "ğŸŒ Network: $DOCKER_NETWORK_NAME"
          echo "ğŸ’¾ Data Volume: $REDIS_DATA_VOLUME"
          echo "ğŸ” Secret: $REDIS_SECRET_NAME"
          echo ""
          echo "âœ… Deployment concluÃ­do com sucesso!"
          echo "ğŸ›¡ï¸ Redis estÃ¡ seguro e acessÃ­vel apenas via rede interna"
          echo "ğŸ’¾ Dados persistentes preservados"
          echo "ğŸ§¹ Limpeza local executada"
          echo "ğŸ”„ Pipeline otimizado para Redis 8.2.1"
          echo "========================================"